// This file is auto-generated by @hey-api/openapi-ts

/**
 * AuditConfig contains the audit logging configuration
 */
export type AuditConfig = {
  /**
   * Component is the component name to use in audit events
   */
  component?: string
  /**
   * EventTypes specifies which event types to audit. If empty, all events are audited.
   */
  event_types?: Array<string>
  /**
   * ExcludeEventTypes specifies which event types to exclude from auditing.
   * This takes precedence over EventTypes.
   */
  exclude_event_types?: Array<string>
  /**
   * IncludeRequestData determines whether to include request data in audit logs
   */
  include_request_data?: boolean
  /**
   * IncludeResponseData determines whether to include response data in audit logs
   */
  include_response_data?: boolean
  /**
   * LogFile specifies the file path for audit logs. If empty, logs to stdout.
   */
  log_file?: string
  /**
   * MaxDataSize limits the size of request/response data included in audit logs (in bytes)
   */
  max_data_size?: number
}

/**
 * OIDCConfig contains OIDC configuration
 */
export type AuthTokenValidatorConfig = {
  /**
   * AllowPrivateIP allows JWKS/OIDC endpoints on private IP addresses
   */
  allowPrivateIP?: boolean
  /**
   * Audience is the expected audience for the token
   */
  audience?: string
  /**
   * AuthTokenFile is the path to file containing bearer token for authentication
   */
  authTokenFile?: string
  /**
   * CACertPath is the path to the CA certificate bundle for HTTPS requests
   */
  cacertPath?: string
  /**
   * ClientID is the OIDC client ID
   */
  clientID?: string
  /**
   * ClientSecret is the optional OIDC client secret for introspection
   */
  clientSecret?: string
  /**
   * IntrospectionURL is the optional introspection endpoint for validating tokens
   */
  introspectionURL?: string
  /**
   * Issuer is the OIDC issuer URL (e.g., https://accounts.google.com)
   */
  issuer?: string
  /**
   * JWKSURL is the URL to fetch the JWKS from
   */
  jwksurl?: string
  /**
   * ResourceURL is the explicit resource URL for OAuth discovery (RFC 9728)
   */
  resourceURL?: string
}

/**
 * Cedar is the Cedar-specific configuration.
 * This is only used when Type is ConfigTypeCedarV1.
 */
export type AuthzCedarConfig = {
  /**
   * EntitiesJSON is the JSON string representing Cedar entities
   */
  entities_json?: string
  /**
   * Policies is a list of Cedar policy strings
   */
  policies?: Array<string>
}

/**
 * AuthzConfig contains the authorization configuration
 */
export type AuthzConfig = {
  cedar?: AuthzCedarConfig
  type?: AuthzConfigType
  /**
   * Version is the version of the configuration format.
   */
  version?: string
}

/**
 * Type is the type of authorization configuration.
 */
export type AuthzConfigType = string

export type ClientMcpClient = string

export type ClientMcpClientStatus = {
  /**
   * ClientType is the type of MCP client
   */
  client_type?: string
  /**
   * Installed indicates whether the client is installed on the system
   */
  installed?: boolean
  /**
   * Registered indicates whether the client is registered in the ToolHive configuration
   */
  registered?: boolean
}

export type ClientRegisteredClient = {
  groups?: Array<string>
  name?: ClientMcpClient
}

export type CoreWorkload = {
  /**
   * CreatedAt is the timestamp when the workload was created.
   */
  created_at?: string
  /**
   * Group is the name of the group this workload belongs to, if any.
   */
  group?: string
  /**
   * Labels are the container labels (excluding standard ToolHive labels)
   */
  labels?: {
    [key: string]: string
  }
  /**
   * Name is the name of the workload.
   * It is used as a unique identifier.
   */
  name?: string
  /**
   * Package specifies the Workload Package used to create this Workload.
   */
  package?: string
  /**
   * Port is the port on which the workload is exposed.
   * This is embedded in the URL.
   */
  port?: number
  /**
   * Remote indicates whether this is a remote workload (true) or a container workload (false).
   */
  remote?: boolean
  status?: RuntimeWorkloadStatus
  /**
   * StatusContext provides additional context about the workload's status.
   * The exact meaning is determined by the status and the underlying runtime.
   */
  status_context?: string
  /**
   * ToolType is the type of tool this workload represents.
   * For now, it will always be "mcp" - representing an MCP server.
   */
  tool_type?: string
  /**
   * ToolsFilter is the filter on tools applied to the workload.
   */
  tools?: Array<string>
  transport_type?: TypesTransportType
  /**
   * URL is the URL of the workload exposed by the ToolHive proxy.
   */
  url?: string
}

export type GroupsGroup = {
  name?: string
  registered_clients?: Array<string>
}

/**
 * IgnoreConfig contains configuration for ignore processing
 */
export type IgnoreConfig = {
  /**
   * Whether to load global ignore patterns
   */
  loadGlobal?: boolean
  /**
   * Whether to print resolved overlay paths for debugging
   */
  printOverlays?: boolean
}

/**
 * Network defines network permissions
 */
export type PermissionsNetworkPermissions = {
  outbound?: PermissionsOutboundNetworkPermissions
}

/**
 * Outbound defines outbound network permissions
 */
export type PermissionsOutboundNetworkPermissions = {
  /**
   * AllowHost is a list of allowed hosts
   */
  allow_host?: Array<string>
  /**
   * AllowPort is a list of allowed ports
   */
  allow_port?: Array<number>
  /**
   * InsecureAllowAll allows all outbound network connections
   */
  insecure_allow_all?: boolean
}

/**
 * PermissionProfile is the permission profile to use
 */
export type PermissionsProfile = {
  /**
   * Name is the name of the profile
   */
  name?: string
  network?: PermissionsNetworkPermissions
  /**
   * Privileged indicates whether the container should run in privileged mode
   * When true, the container has access to all host devices and capabilities
   * Use with extreme caution as this removes most security isolation
   */
  privileged?: boolean
  /**
   * Read is a list of mount declarations that the container can read from
   * These can be in the following formats:
   * - A single path: The same path will be mounted from host to container
   * - host-path:container-path: Different paths for host and container
   * - resource-uri:container-path: Mount a resource identified by URI to a container path
   */
  read?: Array<string>
  /**
   * Write is a list of mount declarations that the container can write to
   * These follow the same format as Read mounts but with write permissions
   */
  write?: Array<string>
}

export type RegistryEnvVar = {
  /**
   * Default is the value to use if the environment variable is not explicitly provided
   * Only used for non-required variables
   */
  default?: string
  /**
   * Description is a human-readable explanation of the variable's purpose
   */
  description?: string
  /**
   * Name is the environment variable name (e.g., API_KEY)
   */
  name?: string
  /**
   * Required indicates whether this environment variable must be provided
   * If true and not provided via command line or secrets, the user will be prompted for a value
   */
  required?: boolean
  /**
   * Secret indicates whether this environment variable contains sensitive information
   * If true, the value will be stored as a secret rather than as a plain environment variable
   */
  secret?: boolean
}

export type RegistryHeader = {
  /**
   * Choices provides a list of valid values for the header (optional)
   */
  choices?: Array<string>
  /**
   * Default is the value to use if the header is not explicitly provided
   * Only used for non-required headers
   */
  default?: string
  /**
   * Description is a human-readable explanation of the header's purpose
   */
  description?: string
  /**
   * Name is the header name (e.g., X-API-Key, Authorization)
   */
  name?: string
  /**
   * Required indicates whether this header must be provided
   * If true and not provided via command line or secrets, the user will be prompted for a value
   */
  required?: boolean
  /**
   * Secret indicates whether this header contains sensitive information
   * If true, the value will be stored as a secret rather than as plain text
   */
  secret?: boolean
}

/**
 * Container server details (if it's a container server)
 */
export type RegistryImageMetadata = {
  /**
   * Args are the default command-line arguments to pass to the MCP server container.
   * These arguments will be used only if no command-line arguments are provided by the user.
   * If the user provides arguments, they will override these defaults.
   */
  args?: Array<string>
  /**
   * CustomMetadata allows for additional user-defined metadata
   */
  custom_metadata?: {
    [key: string]: unknown
  }
  /**
   * Description is a human-readable description of the server's purpose and functionality
   */
  description?: string
  /**
   * DockerTags lists the available Docker tags for this server image
   */
  docker_tags?: Array<string>
  /**
   * EnvVars defines environment variables that can be passed to the server
   */
  env_vars?: Array<RegistryEnvVar>
  /**
   * Image is the Docker image reference for the MCP server
   */
  image?: string
  metadata?: RegistryMetadata
  /**
   * Name is the identifier for the MCP server, used when referencing the server in commands
   * If not provided, it will be auto-generated from the registry key
   */
  name?: string
  permissions?: PermissionsProfile
  provenance?: RegistryProvenance
  /**
   * RepositoryURL is the URL to the source code repository for the server
   */
  repository_url?: string
  /**
   * Status indicates whether the server is currently active or deprecated
   */
  status?: string
  /**
   * Tags are categorization labels for the server to aid in discovery and filtering
   */
  tags?: Array<string>
  /**
   * TargetPort is the port for the container to expose (only applicable to SSE and Streamable HTTP transports)
   */
  target_port?: number
  /**
   * Tier represents the tier classification level of the server, e.g., "Official" or "Community"
   */
  tier?: string
  /**
   * Tools is a list of tool names provided by this MCP server
   */
  tools?: Array<string>
  /**
   * Transport defines the communication protocol for the server
   * For containers: stdio, sse, or streamable-http
   * For remote servers: sse or streamable-http (stdio not supported)
   */
  transport?: string
}

/**
 * Metadata contains additional information about the server such as popularity metrics
 */
export type RegistryMetadata = {
  /**
   * LastUpdated is the timestamp when the server was last updated, in RFC3339 format
   */
  last_updated?: string
  /**
   * Pulls indicates how many times the server image has been downloaded
   */
  pulls?: number
  /**
   * Stars represents the popularity rating or number of stars for the server
   */
  stars?: number
}

/**
 * OAuthConfig provides OAuth/OIDC configuration for authentication to the remote server
 * Used with the thv proxy command's --remote-auth flags
 */
export type RegistryOAuthConfig = {
  /**
   * AuthorizeURL is the OAuth authorization endpoint URL
   * Used for non-OIDC OAuth flows when issuer is not provided
   */
  authorize_url?: string
  /**
   * CallbackPort is the specific port to use for the OAuth callback server
   * If not specified, a random available port will be used
   */
  callback_port?: number
  /**
   * ClientID is the OAuth client ID for authentication
   */
  client_id?: string
  /**
   * Issuer is the OAuth/OIDC issuer URL (e.g., https://accounts.google.com)
   * Used for OIDC discovery to find authorization and token endpoints
   */
  issuer?: string
  /**
   * OAuthParams contains additional OAuth parameters to include in the authorization request
   * These are server-specific parameters like "prompt", "response_mode", etc.
   */
  oauth_params?: {
    [key: string]: string
  }
  /**
   * Scopes are the OAuth scopes to request
   * If not specified, defaults to ["openid", "profile", "email"] for OIDC
   */
  scopes?: Array<string>
  /**
   * TokenURL is the OAuth token endpoint URL
   * Used for non-OIDC OAuth flows when issuer is not provided
   */
  token_url?: string
  /**
   * UsePKCE indicates whether to use PKCE for the OAuth flow
   * Defaults to true for enhanced security
   */
  use_pkce?: boolean
}

/**
 * Provenance contains verification and signing metadata
 */
export type RegistryProvenance = {
  attestation?: RegistryVerifiedAttestation
  cert_issuer?: string
  repository_ref?: string
  repository_uri?: string
  runner_environment?: string
  signer_identity?: string
  sigstore_url?: string
}

/**
 * Full registry data
 */
export type RegistryRegistry = {
  /**
   * LastUpdated is the timestamp when the registry was last updated, in RFC3339 format
   */
  last_updated?: string
  /**
   * RemoteServers is a map of server names to their corresponding remote server definitions
   * These are MCP servers accessed via HTTP/HTTPS using the thv proxy command
   */
  remote_servers?: {
    [key: string]: RegistryRemoteServerMetadata
  }
  /**
   * Servers is a map of server names to their corresponding server definitions
   */
  servers?: {
    [key: string]: RegistryImageMetadata
  }
  /**
   * Version is the schema version of the registry
   */
  version?: string
}

/**
 * Remote server details (if it's a remote server)
 */
export type RegistryRemoteServerMetadata = {
  /**
   * CustomMetadata allows for additional user-defined metadata
   */
  custom_metadata?: {
    [key: string]: unknown
  }
  /**
   * Description is a human-readable description of the server's purpose and functionality
   */
  description?: string
  /**
   * EnvVars defines environment variables that can be passed to configure the client
   * These might be needed for client-side configuration when connecting to the remote server
   */
  env_vars?: Array<RegistryEnvVar>
  /**
   * Headers defines HTTP headers that can be passed to the remote server for authentication
   * These are used with the thv proxy command's authentication features
   */
  headers?: Array<RegistryHeader>
  metadata?: RegistryMetadata
  /**
   * Name is the identifier for the MCP server, used when referencing the server in commands
   * If not provided, it will be auto-generated from the registry key
   */
  name?: string
  oauth_config?: RegistryOAuthConfig
  /**
   * RepositoryURL is the URL to the source code repository for the server
   */
  repository_url?: string
  /**
   * Status indicates whether the server is currently active or deprecated
   */
  status?: string
  /**
   * Tags are categorization labels for the server to aid in discovery and filtering
   */
  tags?: Array<string>
  /**
   * Tier represents the tier classification level of the server, e.g., "Official" or "Community"
   */
  tier?: string
  /**
   * Tools is a list of tool names provided by this MCP server
   */
  tools?: Array<string>
  /**
   * Transport defines the communication protocol for the server
   * For containers: stdio, sse, or streamable-http
   * For remote servers: sse or streamable-http (stdio not supported)
   */
  transport?: string
  /**
   * URL is the endpoint URL for the remote MCP server (e.g., https://api.example.com/mcp)
   */
  url?: string
}

export type RegistryVerifiedAttestation = {
  predicate?: unknown
  predicate_type?: string
}

/**
 * RemoteAuthConfig contains OAuth configuration for remote MCP servers
 */
export type RunnerRemoteAuthConfig = {
  authorizeURL?: string
  callbackPort?: number
  clientID?: string
  clientSecret?: string
  clientSecretFile?: string
  enableRemoteAuth?: boolean
  /**
   * Environment variables for the client
   */
  envVars?: Array<RegistryEnvVar>
  /**
   * Headers for HTTP requests
   */
  headers?: Array<RegistryHeader>
  /**
   * OAuth endpoint configuration (from registry)
   */
  issuer?: string
  /**
   * OAuth parameters for server-specific customization
   */
  oauthParams?: {
    [key: string]: string
  }
  scopes?: Array<string>
  skipBrowser?: boolean
  timeout?: string
  tokenURL?: string
}

export type RunnerRunConfig = {
  audit_config?: AuditConfig
  /**
   * AuditConfigPath is the path to the audit configuration file
   */
  audit_config_path?: string
  authz_config?: AuthzConfig
  /**
   * AuthzConfigPath is the path to the authorization configuration file
   */
  authz_config_path?: string
  /**
   * BaseName is the base name used for the container (without prefixes)
   */
  base_name?: string
  /**
   * CmdArgs are the arguments to pass to the container
   */
  cmd_args?: Array<string>
  /**
   * ContainerLabels are the labels to apply to the container
   */
  container_labels?: {
    [key: string]: string
  }
  /**
   * ContainerName is the name of the container
   */
  container_name?: string
  /**
   * Debug indicates whether debug mode is enabled
   */
  debug?: boolean
  /**
   * EnvVars are the parsed environment variables as key-value pairs
   */
  env_vars?: {
    [key: string]: string
  }
  /**
   * Group is the name of the group this workload belongs to, if any
   */
  group?: string
  /**
   * Host is the host for the HTTP proxy
   */
  host?: string
  ignore_config?: IgnoreConfig
  /**
   * Image is the Docker image to run
   */
  image?: string
  /**
   * IsolateNetwork indicates whether to isolate the network for the container
   */
  isolate_network?: boolean
  /**
   * JWKSAuthTokenFile is the path to file containing auth token for JWKS/OIDC requests
   */
  jwks_auth_token_file?: string
  /**
   * K8sPodTemplatePatch is a JSON string to patch the Kubernetes pod template
   * Only applicable when using Kubernetes runtime
   */
  k8s_pod_template_patch?: string
  /**
   * MiddlewareConfigs contains the list of middleware to apply to the transport
   * and the configuration for each middleware.
   */
  middleware_configs?: Array<TypesMiddlewareConfig>
  /**
   * Name is the name of the MCP server
   */
  name?: string
  oidc_config?: AuthTokenValidatorConfig
  permission_profile?: PermissionsProfile
  /**
   * PermissionProfileNameOrPath is the name or path of the permission profile
   */
  permission_profile_name_or_path?: string
  /**
   * Port is the port for the HTTP proxy to listen on (host port)
   */
  port?: number
  proxy_mode?: TypesProxyMode
  remote_auth_config?: RunnerRemoteAuthConfig
  /**
   * RemoteURL is the URL of the remote MCP server (if running remotely)
   */
  remote_url?: string
  /**
   * SchemaVersion is the version of the RunConfig schema
   */
  schema_version?: string
  /**
   * Secrets are the secret parameters to pass to the container
   * Format: "<secret name>,target=<target environment variable>"
   */
  secrets?: Array<string>
  /**
   * TargetHost is the host to forward traffic to (only applicable to SSE transport)
   */
  target_host?: string
  /**
   * TargetPort is the port for the container to expose (only applicable to SSE transport)
   */
  target_port?: number
  telemetry_config?: TelemetryConfig
  /**
   * ThvCABundle is the path to the CA certificate bundle for ToolHive HTTP operations
   */
  thv_ca_bundle?: string
  /**
   * ToolOverride is the map of tool names to override. Tools to override are
   * specified as ToolOverride structs.
   */
  tool_override?: {
    [key: string]: RunnerToolOverride
  }
  /**
   * ToolOverrideFile is the path to a file containing tool overrides.
   * The file is a JSON struct mapping actual names to ToolOverride structs.
   */
  tool_override_file?: string
  /**
   * ToolsFilter is the list of tools to filter
   */
  tools_filter?: Array<string>
  /**
   * Transport is the transport mode (stdio, sse, or streamable-http)
   */
  transport?: string
  /**
   * Volumes are the directory mounts to pass to the container
   * Format: "host-path:container-path[:ro]"
   */
  volumes?: Array<string>
}

export type RunnerToolOverride = {
  /**
   * Description is the redefined description of the tool
   */
  description?: string
  /**
   * Name is the redefined name of the tool
   */
  name?: string
}

/**
 * Status is the current status of the workload.
 */
export type RuntimeWorkloadStatus = string

export type SecretsSecretParameter = {
  name?: string
  target?: string
}

/**
 * TelemetryConfig contains the OpenTelemetry configuration
 */
export type TelemetryConfig = {
  /**
   * EnablePrometheusMetricsPath controls whether to expose Prometheus-style /metrics endpoint
   * The metrics are served on the main transport port at /metrics
   * This is separate from OTLP metrics which are sent to the Endpoint
   */
  enablePrometheusMetricsPath?: boolean
  /**
   * Endpoint is the OTLP endpoint URL
   */
  endpoint?: string
  /**
   * EnvironmentVariables is a list of environment variable names that should be
   * included in telemetry spans as attributes. Only variables in this list will
   * be read from the host machine and included in spans for observability.
   * Example: []string{"NODE_ENV", "DEPLOYMENT_ENV", "SERVICE_VERSION"}
   */
  environmentVariables?: Array<string>
  /**
   * Headers contains authentication headers for the OTLP endpoint
   */
  headers?: {
    [key: string]: string
  }
  /**
   * Insecure indicates whether to use HTTP instead of HTTPS for the OTLP endpoint
   */
  insecure?: boolean
  /**
   * SamplingRate is the trace sampling rate (0.0-1.0)
   */
  samplingRate?: number
  /**
   * ServiceName is the service name for telemetry
   */
  serviceName?: string
  /**
   * ServiceVersion is the service version for telemetry
   */
  serviceVersion?: string
}

export type TypesMiddlewareConfig = {
  /**
   * Parameters is a JSON object containing the middleware parameters.
   * It is stored as a raw message to allow flexible parameter types.
   */
  parameters?: {
    [key: string]: unknown
  }
  /**
   * Type is a string representing the middleware type.
   */
  type?: string
}

/**
 * ProxyMode is the proxy mode for stdio transport ("sse" or "streamable-http")
 */
export type TypesProxyMode = string

/**
 * TransportType is the type of transport used for this workload.
 */
export type TypesTransportType = string

/**
 * Type of registry (file, url, or default)
 */
export type V1RegistryType = string

/**
 * Request containing registry configuration updates
 */
export type V1UpdateRegistryRequest = {
  /**
   * Allow private IP addresses for registry URL
   */
  allow_private_ip?: boolean
  /**
   * Local registry file path
   */
  local_path?: string
  /**
   * Registry URL (for remote registries)
   */
  url?: string
}

/**
 * Response containing update result
 */
export type V1UpdateRegistryResponse = {
  /**
   * Status message
   */
  message?: string
  /**
   * Registry type after update
   */
  type?: string
}

export type V1BulkClientRequest = {
  /**
   * Groups is the list of groups configured on the client.
   */
  groups?: Array<string>
  /**
   * Names is the list of client names to operate on.
   */
  names?: Array<string>
}

export type V1BulkOperationRequest = {
  /**
   * Group name to operate on (mutually exclusive with names)
   */
  group?: string
  /**
   * Names of the workloads to operate on
   */
  names?: Array<string>
}

export type V1ClientStatusResponse = {
  clients?: Array<ClientMcpClientStatus>
}

export type V1CreateClientRequest = {
  /**
   * Groups is the list of groups configured on the client.
   */
  groups?: Array<string>
  /**
   * Name is the type of the client to register.
   */
  name?: string
}

export type V1CreateClientResponse = {
  /**
   * Groups is the list of groups configured on the client.
   */
  groups?: Array<string>
  /**
   * Name is the type of the client that was registered.
   */
  name?: string
}

export type V1CreateGroupRequest = {
  /**
   * Name of the group to create
   */
  name?: string
}

export type V1CreateGroupResponse = {
  /**
   * Name of the created group
   */
  name?: string
}

/**
 * Request to create a new workload
 */
export type V1CreateRequest = {
  /**
   * Authorization configuration
   */
  authz_config?: string
  /**
   * Command arguments to pass to the container
   */
  cmd_arguments?: Array<string>
  /**
   * Environment variables to set in the container
   */
  env_vars?: {
    [key: string]: string
  }
  /**
   * Host to bind to
   */
  host?: string
  /**
   * Docker image to use
   */
  image?: string
  /**
   * Name of the workload
   */
  name?: string
  /**
   * Whether network isolation is turned on. This applies the rules in the permission profile.
   */
  network_isolation?: boolean
  oidc?: V1OidcOptions
  permission_profile?: PermissionsProfile
  /**
   * Proxy mode to use
   */
  proxy_mode?: string
  /**
   * Secret parameters to inject
   */
  secrets?: Array<SecretsSecretParameter>
  /**
   * Port to expose from the container
   */
  target_port?: number
  /**
   * Tools filter
   */
  tools?: Array<string>
  /**
   * Transport configuration
   */
  transport?: string
  /**
   * Volume mounts
   */
  volumes?: Array<string>
}

/**
 * Request to create a new secret
 */
export type V1CreateSecretRequest = {
  /**
   * Secret key name
   */
  key?: string
  /**
   * Secret value
   */
  value?: string
}

/**
 * Response after creating a secret
 */
export type V1CreateSecretResponse = {
  /**
   * Secret key that was created
   */
  key?: string
  /**
   * Success message
   */
  message?: string
}

/**
 * Response after successfully creating a workload
 */
export type V1CreateWorkloadResponse = {
  /**
   * Name of the created workload
   */
  name?: string
  /**
   * Port the workload is listening on
   */
  port?: number
}

/**
 * Response containing registry details
 */
export type V1GetRegistryResponse = {
  /**
   * Last updated timestamp
   */
  last_updated?: string
  /**
   * Name of the registry
   */
  name?: string
  registry?: RegistryRegistry
  /**
   * Number of servers in the registry
   */
  server_count?: number
  /**
   * Source of the registry (URL, file path, or empty string for built-in)
   */
  source?: string
  /**
   * Type of registry (file, url, or default)
   */
  type?: string
  /**
   * Version of the registry schema
   */
  version?: string
}

/**
 * Response containing secrets provider details
 */
export type V1GetSecretsProviderResponse = {
  capabilities?: V1ProviderCapabilitiesResponse
  /**
   * Name of the secrets provider
   */
  name?: string
  /**
   * Type of the secrets provider
   */
  provider_type?: string
}

/**
 * Response containing server details
 */
export type V1GetServerResponse = {
  /**
   * Indicates if this is a remote server
   */
  is_remote?: boolean
  remote_server?: RegistryRemoteServerMetadata
  server?: RegistryImageMetadata
}

export type V1GroupListResponse = {
  /**
   * List of groups
   */
  groups?: Array<GroupsGroup>
}

/**
 * Response containing a list of secret keys
 */
export type V1ListSecretsResponse = {
  /**
   * List of secret keys
   */
  keys?: Array<V1SecretKeyResponse>
}

/**
 * Response containing a list of servers
 */
export type V1ListServersResponse = {
  /**
   * List of remote servers in the registry (if any)
   */
  remote_servers?: Array<RegistryRemoteServerMetadata>
  /**
   * List of container servers in the registry
   */
  servers?: Array<RegistryImageMetadata>
}

/**
 * OIDC configuration options
 */
export type V1OidcOptions = {
  /**
   * Expected audience
   */
  audience?: string
  /**
   * OAuth2 client ID
   */
  client_id?: string
  /**
   * OAuth2 client secret
   */
  client_secret?: string
  /**
   * Token introspection URL for OIDC
   */
  introspection_url?: string
  /**
   * OIDC issuer URL
   */
  issuer?: string
  /**
   * JWKS URL for key verification
   */
  jwks_url?: string
}

/**
 * Capabilities of the secrets provider
 */
export type V1ProviderCapabilitiesResponse = {
  /**
   * Whether the provider can cleanup all secrets
   */
  can_cleanup?: boolean
  /**
   * Whether the provider can delete secrets
   */
  can_delete?: boolean
  /**
   * Whether the provider can list secrets
   */
  can_list?: boolean
  /**
   * Whether the provider can read secrets
   */
  can_read?: boolean
  /**
   * Whether the provider can write secrets
   */
  can_write?: boolean
}

/**
 * Basic information about a registry
 */
export type V1RegistryInfo = {
  /**
   * Last updated timestamp
   */
  last_updated?: string
  /**
   * Name of the registry
   */
  name?: string
  /**
   * Number of servers in the registry
   */
  server_count?: number
  /**
   * Source of the registry (URL, file path, or empty string for built-in)
   */
  source?: string
  type?: V1RegistryType
  /**
   * Version of the registry schema
   */
  version?: string
}

/**
 * Response containing a list of registries
 */
export type V1RegistryListResponse = {
  /**
   * List of registries
   */
  registries?: Array<V1RegistryInfo>
}

/**
 * Secret key information
 */
export type V1SecretKeyResponse = {
  /**
   * Optional description of the secret
   */
  description?: string
  /**
   * Secret key name
   */
  key?: string
}

/**
 * Request to setup a secrets provider
 */
export type V1SetupSecretsRequest = {
  /**
   * Password for encrypted provider (optional, can be set via environment variable)
   * TODO Review environment variable for this
   */
  password?: string
  /**
   * Type of the secrets provider (encrypted, 1password, none)
   */
  provider_type?: string
}

/**
 * Response after initializing a secrets provider
 */
export type V1SetupSecretsResponse = {
  /**
   * Success message
   */
  message?: string
  /**
   * Type of the secrets provider that was setup
   */
  provider_type?: string
}

/**
 * Request to update an existing workload (name cannot be changed)
 */
export type V1UpdateRequest = {
  /**
   * Authorization configuration
   */
  authz_config?: string
  /**
   * Command arguments to pass to the container
   */
  cmd_arguments?: Array<string>
  /**
   * Environment variables to set in the container
   */
  env_vars?: {
    [key: string]: string
  }
  /**
   * Host to bind to
   */
  host?: string
  /**
   * Docker image to use
   */
  image?: string
  /**
   * Whether network isolation is turned on. This applies the rules in the permission profile.
   */
  network_isolation?: boolean
  oidc?: V1OidcOptions
  permission_profile?: PermissionsProfile
  /**
   * Proxy mode to use
   */
  proxy_mode?: string
  /**
   * Secret parameters to inject
   */
  secrets?: Array<SecretsSecretParameter>
  /**
   * Port to expose from the container
   */
  target_port?: number
  /**
   * Tools filter
   */
  tools?: Array<string>
  /**
   * Transport configuration
   */
  transport?: string
  /**
   * Volume mounts
   */
  volumes?: Array<string>
}

/**
 * Request to update an existing secret
 */
export type V1UpdateSecretRequest = {
  /**
   * New secret value
   */
  value?: string
}

/**
 * Response after updating a secret
 */
export type V1UpdateSecretResponse = {
  /**
   * Secret key that was updated
   */
  key?: string
  /**
   * Success message
   */
  message?: string
}

export type V1VersionResponse = {
  version?: string
}

/**
 * Response containing a list of workloads
 */
export type V1WorkloadListResponse = {
  /**
   * List of container information for each workload
   */
  workloads?: Array<CoreWorkload>
}

/**
 * Response containing workload status information
 */
export type V1WorkloadStatusResponse = {
  /**
   * Current status of the workload
   */
  status?: string
}

export type GetApiOpenapiJsonData = {
  body?: never
  path?: never
  query?: never
  url: '/api/openapi.json'
}

export type GetApiOpenapiJsonResponses = {
  /**
   * OpenAPI specification
   */
  200: {
    [key: string]: unknown
  }
}

export type GetApiOpenapiJsonResponse =
  GetApiOpenapiJsonResponses[keyof GetApiOpenapiJsonResponses]

export type GetApiV1BetaClientsData = {
  body?: never
  path?: never
  query?: never
  url: '/api/v1beta/clients'
}

export type GetApiV1BetaClientsResponses = {
  /**
   * OK
   */
  200: Array<ClientRegisteredClient>
}

export type GetApiV1BetaClientsResponse =
  GetApiV1BetaClientsResponses[keyof GetApiV1BetaClientsResponses]

export type PostApiV1BetaClientsData = {
  /**
   * Client to register
   */
  body: V1CreateClientRequest
  path?: never
  query?: never
  url: '/api/v1beta/clients'
}

export type PostApiV1BetaClientsErrors = {
  /**
   * Invalid request
   */
  400: string
}

export type PostApiV1BetaClientsError =
  PostApiV1BetaClientsErrors[keyof PostApiV1BetaClientsErrors]

export type PostApiV1BetaClientsResponses = {
  /**
   * OK
   */
  200: V1CreateClientResponse
}

export type PostApiV1BetaClientsResponse =
  PostApiV1BetaClientsResponses[keyof PostApiV1BetaClientsResponses]

export type PostApiV1BetaClientsRegisterData = {
  /**
   * Clients to register
   */
  body: V1BulkClientRequest
  path?: never
  query?: never
  url: '/api/v1beta/clients/register'
}

export type PostApiV1BetaClientsRegisterErrors = {
  /**
   * Invalid request
   */
  400: string
}

export type PostApiV1BetaClientsRegisterError =
  PostApiV1BetaClientsRegisterErrors[keyof PostApiV1BetaClientsRegisterErrors]

export type PostApiV1BetaClientsRegisterResponses = {
  /**
   * OK
   */
  200: Array<V1CreateClientResponse>
}

export type PostApiV1BetaClientsRegisterResponse =
  PostApiV1BetaClientsRegisterResponses[keyof PostApiV1BetaClientsRegisterResponses]

export type PostApiV1BetaClientsUnregisterData = {
  /**
   * Clients to unregister
   */
  body: V1BulkClientRequest
  path?: never
  query?: never
  url: '/api/v1beta/clients/unregister'
}

export type PostApiV1BetaClientsUnregisterErrors = {
  /**
   * Invalid request
   */
  400: string
}

export type PostApiV1BetaClientsUnregisterError =
  PostApiV1BetaClientsUnregisterErrors[keyof PostApiV1BetaClientsUnregisterErrors]

export type PostApiV1BetaClientsUnregisterResponses = {
  /**
   * No Content
   */
  204: void
}

export type PostApiV1BetaClientsUnregisterResponse =
  PostApiV1BetaClientsUnregisterResponses[keyof PostApiV1BetaClientsUnregisterResponses]

export type DeleteApiV1BetaClientsByNameData = {
  body?: never
  path: {
    /**
     * Client name to unregister
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/clients/{name}'
}

export type DeleteApiV1BetaClientsByNameErrors = {
  /**
   * Invalid request
   */
  400: string
}

export type DeleteApiV1BetaClientsByNameError =
  DeleteApiV1BetaClientsByNameErrors[keyof DeleteApiV1BetaClientsByNameErrors]

export type DeleteApiV1BetaClientsByNameResponses = {
  /**
   * No Content
   */
  204: void
}

export type DeleteApiV1BetaClientsByNameResponse =
  DeleteApiV1BetaClientsByNameResponses[keyof DeleteApiV1BetaClientsByNameResponses]

export type DeleteApiV1BetaClientsByNameGroupsByGroupData = {
  body?: never
  path: {
    /**
     * Client name to unregister
     */
    name: string
    /**
     * Group name to remove client from
     */
    group: string
  }
  query?: never
  url: '/api/v1beta/clients/{name}/groups/{group}'
}

export type DeleteApiV1BetaClientsByNameGroupsByGroupErrors = {
  /**
   * Invalid request
   */
  400: string
  /**
   * Client or group not found
   */
  404: string
}

export type DeleteApiV1BetaClientsByNameGroupsByGroupError =
  DeleteApiV1BetaClientsByNameGroupsByGroupErrors[keyof DeleteApiV1BetaClientsByNameGroupsByGroupErrors]

export type DeleteApiV1BetaClientsByNameGroupsByGroupResponses = {
  /**
   * No Content
   */
  204: void
}

export type DeleteApiV1BetaClientsByNameGroupsByGroupResponse =
  DeleteApiV1BetaClientsByNameGroupsByGroupResponses[keyof DeleteApiV1BetaClientsByNameGroupsByGroupResponses]

export type GetApiV1BetaDiscoveryClientsData = {
  body?: never
  path?: never
  query?: never
  url: '/api/v1beta/discovery/clients'
}

export type GetApiV1BetaDiscoveryClientsResponses = {
  /**
   * OK
   */
  200: V1ClientStatusResponse
}

export type GetApiV1BetaDiscoveryClientsResponse =
  GetApiV1BetaDiscoveryClientsResponses[keyof GetApiV1BetaDiscoveryClientsResponses]

export type GetApiV1BetaGroupsData = {
  body?: never
  path?: never
  query?: never
  url: '/api/v1beta/groups'
}

export type GetApiV1BetaGroupsErrors = {
  /**
   * Internal Server Error
   */
  500: string
}

export type GetApiV1BetaGroupsError =
  GetApiV1BetaGroupsErrors[keyof GetApiV1BetaGroupsErrors]

export type GetApiV1BetaGroupsResponses = {
  /**
   * OK
   */
  200: V1GroupListResponse
}

export type GetApiV1BetaGroupsResponse =
  GetApiV1BetaGroupsResponses[keyof GetApiV1BetaGroupsResponses]

export type PostApiV1BetaGroupsData = {
  /**
   * Group creation request
   */
  body: V1CreateGroupRequest
  path?: never
  query?: never
  url: '/api/v1beta/groups'
}

export type PostApiV1BetaGroupsErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Conflict
   */
  409: string
  /**
   * Internal Server Error
   */
  500: string
}

export type PostApiV1BetaGroupsError =
  PostApiV1BetaGroupsErrors[keyof PostApiV1BetaGroupsErrors]

export type PostApiV1BetaGroupsResponses = {
  /**
   * Created
   */
  201: V1CreateGroupResponse
}

export type PostApiV1BetaGroupsResponse =
  PostApiV1BetaGroupsResponses[keyof PostApiV1BetaGroupsResponses]

export type DeleteApiV1BetaGroupsByNameData = {
  body?: never
  path: {
    /**
     * Group name
     */
    name: string
  }
  query?: {
    /**
     * Delete all workloads in the group (default: false, moves workloads to default group)
     */
    'with-workloads'?: boolean
  }
  url: '/api/v1beta/groups/{name}'
}

export type DeleteApiV1BetaGroupsByNameErrors = {
  /**
   * Not Found
   */
  404: string
  /**
   * Internal Server Error
   */
  500: string
}

export type DeleteApiV1BetaGroupsByNameError =
  DeleteApiV1BetaGroupsByNameErrors[keyof DeleteApiV1BetaGroupsByNameErrors]

export type DeleteApiV1BetaGroupsByNameResponses = {
  /**
   * No Content
   */
  204: string
}

export type DeleteApiV1BetaGroupsByNameResponse =
  DeleteApiV1BetaGroupsByNameResponses[keyof DeleteApiV1BetaGroupsByNameResponses]

export type GetApiV1BetaGroupsByNameData = {
  body?: never
  path: {
    /**
     * Group name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/groups/{name}'
}

export type GetApiV1BetaGroupsByNameErrors = {
  /**
   * Not Found
   */
  404: string
  /**
   * Internal Server Error
   */
  500: string
}

export type GetApiV1BetaGroupsByNameError =
  GetApiV1BetaGroupsByNameErrors[keyof GetApiV1BetaGroupsByNameErrors]

export type GetApiV1BetaGroupsByNameResponses = {
  /**
   * OK
   */
  200: GroupsGroup
}

export type GetApiV1BetaGroupsByNameResponse =
  GetApiV1BetaGroupsByNameResponses[keyof GetApiV1BetaGroupsByNameResponses]

export type GetApiV1BetaRegistryData = {
  body?: never
  path?: never
  query?: never
  url: '/api/v1beta/registry'
}

export type GetApiV1BetaRegistryResponses = {
  /**
   * OK
   */
  200: V1RegistryListResponse
}

export type GetApiV1BetaRegistryResponse =
  GetApiV1BetaRegistryResponses[keyof GetApiV1BetaRegistryResponses]

export type PostApiV1BetaRegistryData = {
  body?: {
    [key: string]: unknown
  }
  path?: never
  query?: never
  url: '/api/v1beta/registry'
}

export type PostApiV1BetaRegistryErrors = {
  /**
   * Not Implemented
   */
  501: string
}

export type PostApiV1BetaRegistryError =
  PostApiV1BetaRegistryErrors[keyof PostApiV1BetaRegistryErrors]

export type DeleteApiV1BetaRegistryByNameData = {
  body?: never
  path: {
    /**
     * Registry name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/registry/{name}'
}

export type DeleteApiV1BetaRegistryByNameErrors = {
  /**
   * Not Found
   */
  404: string
}

export type DeleteApiV1BetaRegistryByNameError =
  DeleteApiV1BetaRegistryByNameErrors[keyof DeleteApiV1BetaRegistryByNameErrors]

export type DeleteApiV1BetaRegistryByNameResponses = {
  /**
   * No Content
   */
  204: string
}

export type DeleteApiV1BetaRegistryByNameResponse =
  DeleteApiV1BetaRegistryByNameResponses[keyof DeleteApiV1BetaRegistryByNameResponses]

export type GetApiV1BetaRegistryByNameData = {
  body?: never
  path: {
    /**
     * Registry name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/registry/{name}'
}

export type GetApiV1BetaRegistryByNameErrors = {
  /**
   * Not Found
   */
  404: string
}

export type GetApiV1BetaRegistryByNameError =
  GetApiV1BetaRegistryByNameErrors[keyof GetApiV1BetaRegistryByNameErrors]

export type GetApiV1BetaRegistryByNameResponses = {
  /**
   * OK
   */
  200: V1GetRegistryResponse
}

export type GetApiV1BetaRegistryByNameResponse =
  GetApiV1BetaRegistryByNameResponses[keyof GetApiV1BetaRegistryByNameResponses]

export type PutApiV1BetaRegistryByNameData = {
  /**
   * Registry configuration
   */
  body: V1UpdateRegistryRequest
  path: {
    /**
     * Registry name (must be 'default')
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/registry/{name}'
}

export type PutApiV1BetaRegistryByNameErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found
   */
  404: string
}

export type PutApiV1BetaRegistryByNameError =
  PutApiV1BetaRegistryByNameErrors[keyof PutApiV1BetaRegistryByNameErrors]

export type PutApiV1BetaRegistryByNameResponses = {
  /**
   * OK
   */
  200: V1UpdateRegistryResponse
}

export type PutApiV1BetaRegistryByNameResponse =
  PutApiV1BetaRegistryByNameResponses[keyof PutApiV1BetaRegistryByNameResponses]

export type GetApiV1BetaRegistryByNameServersData = {
  body?: never
  path: {
    /**
     * Registry name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/registry/{name}/servers'
}

export type GetApiV1BetaRegistryByNameServersErrors = {
  /**
   * Not Found
   */
  404: string
}

export type GetApiV1BetaRegistryByNameServersError =
  GetApiV1BetaRegistryByNameServersErrors[keyof GetApiV1BetaRegistryByNameServersErrors]

export type GetApiV1BetaRegistryByNameServersResponses = {
  /**
   * OK
   */
  200: V1ListServersResponse
}

export type GetApiV1BetaRegistryByNameServersResponse =
  GetApiV1BetaRegistryByNameServersResponses[keyof GetApiV1BetaRegistryByNameServersResponses]

export type GetApiV1BetaRegistryByNameServersByServerNameData = {
  body?: never
  path: {
    /**
     * Registry name
     */
    name: string
    /**
     * ImageMetadata name
     */
    serverName: string
  }
  query?: never
  url: '/api/v1beta/registry/{name}/servers/{serverName}'
}

export type GetApiV1BetaRegistryByNameServersByServerNameErrors = {
  /**
   * Not Found
   */
  404: string
}

export type GetApiV1BetaRegistryByNameServersByServerNameError =
  GetApiV1BetaRegistryByNameServersByServerNameErrors[keyof GetApiV1BetaRegistryByNameServersByServerNameErrors]

export type GetApiV1BetaRegistryByNameServersByServerNameResponses = {
  /**
   * OK
   */
  200: V1GetServerResponse
}

export type GetApiV1BetaRegistryByNameServersByServerNameResponse =
  GetApiV1BetaRegistryByNameServersByServerNameResponses[keyof GetApiV1BetaRegistryByNameServersByServerNameResponses]

export type PostApiV1BetaSecretsData = {
  /**
   * Setup secrets provider request
   */
  body: V1SetupSecretsRequest
  path?: never
  query?: never
  url: '/api/v1beta/secrets'
}

export type PostApiV1BetaSecretsErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Internal Server Error
   */
  500: string
}

export type PostApiV1BetaSecretsError =
  PostApiV1BetaSecretsErrors[keyof PostApiV1BetaSecretsErrors]

export type PostApiV1BetaSecretsResponses = {
  /**
   * Created
   */
  201: V1SetupSecretsResponse
}

export type PostApiV1BetaSecretsResponse =
  PostApiV1BetaSecretsResponses[keyof PostApiV1BetaSecretsResponses]

export type GetApiV1BetaSecretsDefaultData = {
  body?: never
  path?: never
  query?: never
  url: '/api/v1beta/secrets/default'
}

export type GetApiV1BetaSecretsDefaultErrors = {
  /**
   * Not Found - Provider not setup
   */
  404: string
  /**
   * Internal Server Error
   */
  500: string
}

export type GetApiV1BetaSecretsDefaultError =
  GetApiV1BetaSecretsDefaultErrors[keyof GetApiV1BetaSecretsDefaultErrors]

export type GetApiV1BetaSecretsDefaultResponses = {
  /**
   * OK
   */
  200: V1GetSecretsProviderResponse
}

export type GetApiV1BetaSecretsDefaultResponse =
  GetApiV1BetaSecretsDefaultResponses[keyof GetApiV1BetaSecretsDefaultResponses]

export type GetApiV1BetaSecretsDefaultKeysData = {
  body?: never
  path?: never
  query?: never
  url: '/api/v1beta/secrets/default/keys'
}

export type GetApiV1BetaSecretsDefaultKeysErrors = {
  /**
   * Not Found - Provider not setup
   */
  404: string
  /**
   * Method Not Allowed - Provider doesn't support listing
   */
  405: string
  /**
   * Internal Server Error
   */
  500: string
}

export type GetApiV1BetaSecretsDefaultKeysError =
  GetApiV1BetaSecretsDefaultKeysErrors[keyof GetApiV1BetaSecretsDefaultKeysErrors]

export type GetApiV1BetaSecretsDefaultKeysResponses = {
  /**
   * OK
   */
  200: V1ListSecretsResponse
}

export type GetApiV1BetaSecretsDefaultKeysResponse =
  GetApiV1BetaSecretsDefaultKeysResponses[keyof GetApiV1BetaSecretsDefaultKeysResponses]

export type PostApiV1BetaSecretsDefaultKeysData = {
  /**
   * Create secret request
   */
  body: V1CreateSecretRequest
  path?: never
  query?: never
  url: '/api/v1beta/secrets/default/keys'
}

export type PostApiV1BetaSecretsDefaultKeysErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found - Provider not setup
   */
  404: string
  /**
   * Method Not Allowed - Provider doesn't support writing
   */
  405: string
  /**
   * Conflict - Secret already exists
   */
  409: string
  /**
   * Internal Server Error
   */
  500: string
}

export type PostApiV1BetaSecretsDefaultKeysError =
  PostApiV1BetaSecretsDefaultKeysErrors[keyof PostApiV1BetaSecretsDefaultKeysErrors]

export type PostApiV1BetaSecretsDefaultKeysResponses = {
  /**
   * Created
   */
  201: V1CreateSecretResponse
}

export type PostApiV1BetaSecretsDefaultKeysResponse =
  PostApiV1BetaSecretsDefaultKeysResponses[keyof PostApiV1BetaSecretsDefaultKeysResponses]

export type DeleteApiV1BetaSecretsDefaultKeysByKeyData = {
  body?: never
  path: {
    /**
     * Secret key
     */
    key: string
  }
  query?: never
  url: '/api/v1beta/secrets/default/keys/{key}'
}

export type DeleteApiV1BetaSecretsDefaultKeysByKeyErrors = {
  /**
   * Not Found - Provider not setup or secret not found
   */
  404: string
  /**
   * Method Not Allowed - Provider doesn't support deletion
   */
  405: string
  /**
   * Internal Server Error
   */
  500: string
}

export type DeleteApiV1BetaSecretsDefaultKeysByKeyError =
  DeleteApiV1BetaSecretsDefaultKeysByKeyErrors[keyof DeleteApiV1BetaSecretsDefaultKeysByKeyErrors]

export type DeleteApiV1BetaSecretsDefaultKeysByKeyResponses = {
  /**
   * No Content
   */
  204: string
}

export type DeleteApiV1BetaSecretsDefaultKeysByKeyResponse =
  DeleteApiV1BetaSecretsDefaultKeysByKeyResponses[keyof DeleteApiV1BetaSecretsDefaultKeysByKeyResponses]

export type PutApiV1BetaSecretsDefaultKeysByKeyData = {
  /**
   * Update secret request
   */
  body: V1UpdateSecretRequest
  path: {
    /**
     * Secret key
     */
    key: string
  }
  query?: never
  url: '/api/v1beta/secrets/default/keys/{key}'
}

export type PutApiV1BetaSecretsDefaultKeysByKeyErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found - Provider not setup or secret not found
   */
  404: string
  /**
   * Method Not Allowed - Provider doesn't support writing
   */
  405: string
  /**
   * Internal Server Error
   */
  500: string
}

export type PutApiV1BetaSecretsDefaultKeysByKeyError =
  PutApiV1BetaSecretsDefaultKeysByKeyErrors[keyof PutApiV1BetaSecretsDefaultKeysByKeyErrors]

export type PutApiV1BetaSecretsDefaultKeysByKeyResponses = {
  /**
   * OK
   */
  200: V1UpdateSecretResponse
}

export type PutApiV1BetaSecretsDefaultKeysByKeyResponse =
  PutApiV1BetaSecretsDefaultKeysByKeyResponses[keyof PutApiV1BetaSecretsDefaultKeysByKeyResponses]

export type GetApiV1BetaVersionData = {
  body?: never
  path?: never
  query?: never
  url: '/api/v1beta/version'
}

export type GetApiV1BetaVersionResponses = {
  /**
   * OK
   */
  200: V1VersionResponse
}

export type GetApiV1BetaVersionResponse =
  GetApiV1BetaVersionResponses[keyof GetApiV1BetaVersionResponses]

export type GetApiV1BetaWorkloadsData = {
  body?: never
  path?: never
  query?: {
    /**
     * List all workloads, including stopped ones
     */
    all?: boolean
    /**
     * Filter workloads by group name
     */
    group?: string
  }
  url: '/api/v1beta/workloads'
}

export type GetApiV1BetaWorkloadsErrors = {
  /**
   * Group not found
   */
  404: string
}

export type GetApiV1BetaWorkloadsError =
  GetApiV1BetaWorkloadsErrors[keyof GetApiV1BetaWorkloadsErrors]

export type GetApiV1BetaWorkloadsResponses = {
  /**
   * OK
   */
  200: V1WorkloadListResponse
}

export type GetApiV1BetaWorkloadsResponse =
  GetApiV1BetaWorkloadsResponses[keyof GetApiV1BetaWorkloadsResponses]

export type PostApiV1BetaWorkloadsData = {
  /**
   * Create workload request
   */
  body: V1CreateRequest
  path?: never
  query?: never
  url: '/api/v1beta/workloads'
}

export type PostApiV1BetaWorkloadsErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Conflict
   */
  409: string
}

export type PostApiV1BetaWorkloadsError =
  PostApiV1BetaWorkloadsErrors[keyof PostApiV1BetaWorkloadsErrors]

export type PostApiV1BetaWorkloadsResponses = {
  /**
   * Created
   */
  201: V1CreateWorkloadResponse
}

export type PostApiV1BetaWorkloadsResponse =
  PostApiV1BetaWorkloadsResponses[keyof PostApiV1BetaWorkloadsResponses]

export type PostApiV1BetaWorkloadsDeleteData = {
  /**
   * Bulk delete request (names or group)
   */
  body: V1BulkOperationRequest
  path?: never
  query?: never
  url: '/api/v1beta/workloads/delete'
}

export type PostApiV1BetaWorkloadsDeleteErrors = {
  /**
   * Bad Request
   */
  400: string
}

export type PostApiV1BetaWorkloadsDeleteError =
  PostApiV1BetaWorkloadsDeleteErrors[keyof PostApiV1BetaWorkloadsDeleteErrors]

export type PostApiV1BetaWorkloadsDeleteResponses = {
  /**
   * Accepted
   */
  202: string
}

export type PostApiV1BetaWorkloadsDeleteResponse =
  PostApiV1BetaWorkloadsDeleteResponses[keyof PostApiV1BetaWorkloadsDeleteResponses]

export type PostApiV1BetaWorkloadsRestartData = {
  /**
   * Bulk restart request (names or group)
   */
  body: V1BulkOperationRequest
  path?: never
  query?: never
  url: '/api/v1beta/workloads/restart'
}

export type PostApiV1BetaWorkloadsRestartErrors = {
  /**
   * Bad Request
   */
  400: string
}

export type PostApiV1BetaWorkloadsRestartError =
  PostApiV1BetaWorkloadsRestartErrors[keyof PostApiV1BetaWorkloadsRestartErrors]

export type PostApiV1BetaWorkloadsRestartResponses = {
  /**
   * Accepted
   */
  202: string
}

export type PostApiV1BetaWorkloadsRestartResponse =
  PostApiV1BetaWorkloadsRestartResponses[keyof PostApiV1BetaWorkloadsRestartResponses]

export type PostApiV1BetaWorkloadsStopData = {
  /**
   * Bulk stop request (names or group)
   */
  body: V1BulkOperationRequest
  path?: never
  query?: never
  url: '/api/v1beta/workloads/stop'
}

export type PostApiV1BetaWorkloadsStopErrors = {
  /**
   * Bad Request
   */
  400: string
}

export type PostApiV1BetaWorkloadsStopError =
  PostApiV1BetaWorkloadsStopErrors[keyof PostApiV1BetaWorkloadsStopErrors]

export type PostApiV1BetaWorkloadsStopResponses = {
  /**
   * Accepted
   */
  202: string
}

export type PostApiV1BetaWorkloadsStopResponse =
  PostApiV1BetaWorkloadsStopResponses[keyof PostApiV1BetaWorkloadsStopResponses]

export type DeleteApiV1BetaWorkloadsByNameData = {
  body?: never
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}'
}

export type DeleteApiV1BetaWorkloadsByNameErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found
   */
  404: string
}

export type DeleteApiV1BetaWorkloadsByNameError =
  DeleteApiV1BetaWorkloadsByNameErrors[keyof DeleteApiV1BetaWorkloadsByNameErrors]

export type DeleteApiV1BetaWorkloadsByNameResponses = {
  /**
   * Accepted
   */
  202: string
}

export type DeleteApiV1BetaWorkloadsByNameResponse =
  DeleteApiV1BetaWorkloadsByNameResponses[keyof DeleteApiV1BetaWorkloadsByNameResponses]

export type GetApiV1BetaWorkloadsByNameData = {
  body?: never
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}'
}

export type GetApiV1BetaWorkloadsByNameErrors = {
  /**
   * Not Found
   */
  404: string
}

export type GetApiV1BetaWorkloadsByNameError =
  GetApiV1BetaWorkloadsByNameErrors[keyof GetApiV1BetaWorkloadsByNameErrors]

export type GetApiV1BetaWorkloadsByNameResponses = {
  /**
   * OK
   */
  200: V1CreateRequest
}

export type GetApiV1BetaWorkloadsByNameResponse =
  GetApiV1BetaWorkloadsByNameResponses[keyof GetApiV1BetaWorkloadsByNameResponses]

export type PostApiV1BetaWorkloadsByNameEditData = {
  /**
   * Update workload request
   */
  body: V1UpdateRequest
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}/edit'
}

export type PostApiV1BetaWorkloadsByNameEditErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found
   */
  404: string
}

export type PostApiV1BetaWorkloadsByNameEditError =
  PostApiV1BetaWorkloadsByNameEditErrors[keyof PostApiV1BetaWorkloadsByNameEditErrors]

export type PostApiV1BetaWorkloadsByNameEditResponses = {
  /**
   * OK
   */
  200: V1CreateWorkloadResponse
}

export type PostApiV1BetaWorkloadsByNameEditResponse =
  PostApiV1BetaWorkloadsByNameEditResponses[keyof PostApiV1BetaWorkloadsByNameEditResponses]

export type GetApiV1BetaWorkloadsByNameExportData = {
  body?: never
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}/export'
}

export type GetApiV1BetaWorkloadsByNameExportErrors = {
  /**
   * Not Found
   */
  404: string
}

export type GetApiV1BetaWorkloadsByNameExportError =
  GetApiV1BetaWorkloadsByNameExportErrors[keyof GetApiV1BetaWorkloadsByNameExportErrors]

export type GetApiV1BetaWorkloadsByNameExportResponses = {
  /**
   * OK
   */
  200: RunnerRunConfig
}

export type GetApiV1BetaWorkloadsByNameExportResponse =
  GetApiV1BetaWorkloadsByNameExportResponses[keyof GetApiV1BetaWorkloadsByNameExportResponses]

export type GetApiV1BetaWorkloadsByNameLogsData = {
  body?: never
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}/logs'
}

export type GetApiV1BetaWorkloadsByNameLogsErrors = {
  /**
   * Not Found
   */
  404: string
}

export type GetApiV1BetaWorkloadsByNameLogsError =
  GetApiV1BetaWorkloadsByNameLogsErrors[keyof GetApiV1BetaWorkloadsByNameLogsErrors]

export type GetApiV1BetaWorkloadsByNameLogsResponses = {
  /**
   * Logs for the specified workload
   */
  200: string
}

export type GetApiV1BetaWorkloadsByNameLogsResponse =
  GetApiV1BetaWorkloadsByNameLogsResponses[keyof GetApiV1BetaWorkloadsByNameLogsResponses]

export type PostApiV1BetaWorkloadsByNameRestartData = {
  body?: never
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}/restart'
}

export type PostApiV1BetaWorkloadsByNameRestartErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found
   */
  404: string
}

export type PostApiV1BetaWorkloadsByNameRestartError =
  PostApiV1BetaWorkloadsByNameRestartErrors[keyof PostApiV1BetaWorkloadsByNameRestartErrors]

export type PostApiV1BetaWorkloadsByNameRestartResponses = {
  /**
   * Accepted
   */
  202: string
}

export type PostApiV1BetaWorkloadsByNameRestartResponse =
  PostApiV1BetaWorkloadsByNameRestartResponses[keyof PostApiV1BetaWorkloadsByNameRestartResponses]

export type GetApiV1BetaWorkloadsByNameStatusData = {
  body?: never
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}/status'
}

export type GetApiV1BetaWorkloadsByNameStatusErrors = {
  /**
   * Not Found
   */
  404: string
}

export type GetApiV1BetaWorkloadsByNameStatusError =
  GetApiV1BetaWorkloadsByNameStatusErrors[keyof GetApiV1BetaWorkloadsByNameStatusErrors]

export type GetApiV1BetaWorkloadsByNameStatusResponses = {
  /**
   * OK
   */
  200: V1WorkloadStatusResponse
}

export type GetApiV1BetaWorkloadsByNameStatusResponse =
  GetApiV1BetaWorkloadsByNameStatusResponses[keyof GetApiV1BetaWorkloadsByNameStatusResponses]

export type PostApiV1BetaWorkloadsByNameStopData = {
  body?: never
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}/stop'
}

export type PostApiV1BetaWorkloadsByNameStopErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found
   */
  404: string
}

export type PostApiV1BetaWorkloadsByNameStopError =
  PostApiV1BetaWorkloadsByNameStopErrors[keyof PostApiV1BetaWorkloadsByNameStopErrors]

export type PostApiV1BetaWorkloadsByNameStopResponses = {
  /**
   * Accepted
   */
  202: string
}

export type PostApiV1BetaWorkloadsByNameStopResponse =
  PostApiV1BetaWorkloadsByNameStopResponses[keyof PostApiV1BetaWorkloadsByNameStopResponses]

export type GetHealthData = {
  body?: never
  path?: never
  query?: never
  url: '/health'
}

export type GetHealthResponses = {
  /**
   * No Content
   */
  204: string
}

export type GetHealthResponse = GetHealthResponses[keyof GetHealthResponses]

export type ClientOptions = {
  baseUrl: `${string}://${string}` | (string & {})
}
