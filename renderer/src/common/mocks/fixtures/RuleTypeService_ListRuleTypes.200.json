{
  "ruleTypes": [
    {
      "id": "57e75208-1bf7-448e-b74c-b1038dfe7c0b",
      "name": "stacklok/dependabot_configured",
      "displayName": "stacklok/dependabot_configured",
      "shortFailureMessage": "Dependabot is not configured",
      "context": {
        "provider": "",
        "project": "264d58cd-8746-47f3-b29c-48a98889f8b9"
      },
      "def": {
        "inEntity": "repository",
        "ruleSchema": {
          "properties": {
            "apply_if_file": {
              "description": "Optional. If specified, the rule will only be evaluated if the given file exists.\nThis is useful for rules that are only applicable to certain types of repositories.\n",
              "type": "string"
            },
            "package_ecosystem": {
              "description": "The package ecosystem that the rule applies to.\nFor example pip, gomod, npm, docker, github-actions, etc.\n",
              "type": "string"
            },
            "schedule_interval": {
              "description": "This option is no longer used. It's, however marked as required, so we can't remove\nit for backwards compatibility.\n",
              "type": "string"
            }
          },
          "required": ["package_ecosystem", "schedule_interval"],
          "type": "object"
        },
        "ingest": {
          "type": "git",
          "git": {
            "cloneUrl": "",
            "branch": ""
          }
        },
        "eval": {
          "type": "rego",
          "jq": [],
          "rego": {
            "type": "deny-by-default",
            "def": "package minder\n\ndefault allow := false\n\n# Set allow if we don't need to skip and the rule evaluation passes\nallow {\n    # Read the dependabot configuration\n    fileStr := file.read(\"./.github/dependabot.yml\")\n\n    # Parse the YAML content\n    config := yaml.unmarshal(fileStr)\n\n    # Ensure a configuration contains the package ecosystem daily update schedule\n    update := config.updates[_]\n    update[\"package-ecosystem\"] == input.profile.package_ecosystem\n}\n\n# We skip if the apply_if_file is specified and the file does not exist\nskip {\n    input.profile.apply_if_file != \"\"\n    not file.exists(input.profile.apply_if_file)\n}\n"
          }
        },
        "remediate": {
          "type": "pull_request",
          "pullRequest": {
            "title": "Add Dependabot configuration for {{.Profile.package_ecosystem }}",
            "body": "This is a Minder automated pull request.\n\nThis pull request adds a Dependabot configuration to the repository to handle\npackage updates for {{.Profile.package_ecosystem }}.\n\nFor more information, see\nhttps://docs.github.com/en/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file\n",
            "contents": [
              {
                "path": ".github/dependabot.yml",
                "action": "replace",
                "content": "version: 2\nupdates:\n  - package-ecosystem: \"{{.Profile.package_ecosystem }}\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n    open-pull-requests-limit: 10\n"
              }
            ],
            "method": ""
          }
        },
        "alert": {
          "type": "security_advisory",
          "securityAdvisory": {
            "severity": ""
          }
        }
      },
      "description": "Verifies that Dependabot is configured for the repository",
      "guidance": "Ensure that Dependabot is configured and enabled for the repository.\n\nDependabot enables Automated dependency updates for repositories.\nIt is recommended that repositories have some form of automated dependency updates enabled\nto ensure that vulnerabilities are not introduced into the codebase.\n\nFor more information, see\nhttps://docs.github.com/en/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file\n",
      "severity": {
        "value": "VALUE_MEDIUM"
      },
      "releasePhase": "RULE_TYPE_RELEASE_PHASE_ALPHA"
    },
    {
      "id": "5da88ea9-ce0e-434a-936a-89a10c46f4a2",
      "name": "stacklok/allowed_selected_actions",
      "displayName": "stacklok/allowed_selected_actions",
      "shortFailureMessage": "Non-allowed action was selected",
      "context": {
        "provider": "",
        "project": "264d58cd-8746-47f3-b29c-48a98889f8b9"
      },
      "def": {
        "inEntity": "repository",
        "ruleSchema": {
          "properties": {
            "github_owned_allowed": {
              "description": "Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization.",
              "type": "boolean"
            },
            "patterns_allowed": {
              "description": "Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`.\n\n**Note**: The `patterns_allowed` setting only applies to public repositories.",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "verified_allowed": {
              "description": "Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators.",
              "type": "boolean"
            }
          },
          "type": "object"
        },
        "ingest": {
          "type": "rest",
          "rest": {
            "endpoint": "/repos/{{.Entity.Owner}}/{{.Entity.Name}}/actions/permissions/selected-actions",
            "method": "",
            "headers": [],
            "parse": "json",
            "fallback": [
              {
                "httpCode": 409,
                "body": "{\"http_status\": 404, \"message\": \"Not Protected\"}\n"
              }
            ]
          }
        },
        "eval": {
          "type": "jq",
          "jq": [
            {
              "ingested": {
                "def": ".github_owned_allowed"
              },
              "profile": {
                "def": ".github_owned_allowed"
              }
            },
            {
              "ingested": {
                "def": ".verified_allowed"
              },
              "profile": {
                "def": ".verified_allowed"
              }
            },
            {
              "ingested": {
                "def": ".patterns_allowed"
              },
              "profile": {
                "def": ".patterns_allowed"
              }
            }
          ]
        },
        "remediate": {
          "type": "rest",
          "rest": {
            "endpoint": "/repos/{{.Entity.Owner}}/{{.Entity.Name}}/actions/permissions/selected-actions",
            "method": "PUT",
            "headers": [],
            "body": "{\"github_owned_allowed\":{{ .Profile.github_owned_allowed }},\"verified_allowed\":{{ .Profile.verified_allowed }},\"patterns_allowed\":[{{range $index, $pattern := .Profile.patterns_allowed}}{{if $index}},{{end}}\"{{ $pattern }}\"{{end}}]}\n",
            "parse": "",
            "fallback": []
          }
        },
        "alert": {
          "type": "security_advisory",
          "securityAdvisory": {
            "severity": ""
          }
        }
      },
      "description": "Verifies the settings for selected actions and reusable workflows that are allowed\nin a repository. To use this rule, the repository profile for allowed_actions must\nbe configured to selected.\n",
      "guidance": "Ensure that only the actions and reusable workflows that are allowed in the repository\nare set.\n\nHaving an overview over which actions and reusable workflows are allowed in a repository is important and allows for a better overall security posture.\n\nFor more information, see\nhttps://docs.github.com/en/rest/actions/permissions#set-allowed-actions-and-reusable-workflows-for-a-repository\n",
      "severity": {
        "value": "VALUE_MEDIUM"
      },
      "releasePhase": "RULE_TYPE_RELEASE_PHASE_BETA"
    },
    {
      "id": "4eecf4f7-c5dd-43ed-8738-03a5e86d4ed3",
      "name": "stacklok/branch_protection_allow_force_pushes",
      "displayName": "stacklok/branch_protection_allow_force_pushes",
      "shortFailureMessage": "Force pushes are allowed but they shouldn't be",
      "context": {
        "provider": "",
        "project": "264d58cd-8746-47f3-b29c-48a98889f8b9"
      },
      "def": {
        "inEntity": "repository",
        "ruleSchema": {
          "properties": {
            "allow_force_pushes": {
              "description": "Permits force pushes to the protected branch by anyone with write access to the repository.",
              "type": "boolean"
            }
          },
          "required": ["allow_force_pushes"]
        },
        "paramSchema": {
          "properties": {
            "branch": {
              "description": "The name of the branch to check. If left empty, the default branch will be used.",
              "type": "string"
            }
          },
          "required": ["branch"]
        },
        "ingest": {
          "type": "rest",
          "rest": {
            "endpoint": "{{ $branch_param := index .Params \"branch\" }}/repos/{{.Entity.Owner}}/{{.Entity.Name}}/branches/{{if ne $branch_param \"\" }}{{ $branch_param }}{{ else }}{{ .Entity.DefaultBranch }}{{ end }}/protection",
            "method": "",
            "headers": [],
            "parse": "json",
            "fallback": [
              {
                "httpCode": 404,
                "body": "{\"http_status\": 404, \"message\": \"Not Protected\"}\n"
              }
            ]
          }
        },
        "eval": {
          "type": "jq",
          "jq": [
            {
              "ingested": {
                "def": ".allow_force_pushes.enabled"
              },
              "profile": {
                "def": ".allow_force_pushes"
              }
            }
          ]
        },
        "remediate": {
          "type": "gh_branch_protection",
          "ghBranchProtection": {
            "patch": "{\"allow_force_pushes\":{{ .Profile.allow_force_pushes }} }\n"
          }
        },
        "alert": {
          "type": "security_advisory",
          "securityAdvisory": {
            "severity": ""
          }
        }
      },
      "description": "Whether force pushes are allowed to the branch",
      "guidance": "Ensure that the appropriate setting is enabled for the branch protection rule.\n\nThis setting allows users with push access to force push to the branch.\n\nFor more information, see\nhttps://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/managing-a-branch-protection-rule\n",
      "severity": {
        "value": "VALUE_MEDIUM"
      },
      "releasePhase": "RULE_TYPE_RELEASE_PHASE_DEPRECATED"
    },
    {
      "id": "3c68a778-0682-469b-90af-dcb6f65a4f13",
      "name": "stacklok/repo_action_allow_list",
      "displayName": "stacklok/repo_action_allow_list",
      "shortFailureMessage": "This rule failed for whatever reason",
      "context": {
        "provider": "",
        "project": "264d58cd-8746-47f3-b29c-48a98889f8b9"
      },
      "def": {
        "inEntity": "repository",
        "ruleSchema": {
          "properties": {
            "actions": {
              "description": "List of actions that are allowed to be used in the repository.\nThe list should be in the format of `owner/repo`\nFor example, `actions/checkout`\n",
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "type": "object"
        },
        "ingest": {
          "type": "git",
          "git": {
            "cloneUrl": "",
            "branch": "main"
          }
        },
        "eval": {
          "type": "rego",
          "jq": [],
          "rego": {
            "type": "constraints",
            "def": "package minder\n\nexpected_set := {x | x := input.profile.actions[_]}\nactions := github_workflow.ls_actions(\"./.github/workflows\")\n\nviolations[{\"msg\": msg}] {\n  extra := actions - expected_set\n  not count(extra) == 0\n  msg = format_message(extra, input.output_format)\n}\n\nformat_message(difference, format) = msg {\n    format == \"json\"\n    json_body := {\"actions_not_allowed\": difference}\n    msg := json.marshal(json_body)\n}\n\nformat_message(difference, format) = msg {\n    not format == \"json\"\n    msg := sprintf(\"extra actions found in workflows but not allowed in the profile: %v\", [difference])\n}\n",
            "violationFormat": "json"
          }
        },
        "alert": {
          "type": "security_advisory",
          "securityAdvisory": {
            "severity": ""
          }
        }
      },
      "description": "Verifies that the github workflows in a repo only use actions enumerated in the rule.\n",
      "guidance": "Ensure that the workflows in a repository only use actions that are allowed in the profile.\n\nHaving an overview over which actions and reusable workflows are allowed in a repository is important and allows for a better overall security posture.\n\nFor more information, see\nhttps://docs.github.com/en/rest/actions/permissions#set-allowed-actions-and-reusable-workflows-for-a-repository\n",
      "severity": {
        "value": "VALUE_INFO"
      },
      "releasePhase": "RULE_TYPE_RELEASE_PHASE_ALPHA"
    },
    {
      "id": "a52e7379-c955-4d74-8b4b-e26f3562b266",
      "name": "stacklok/secret_scanning",
      "displayName": "stacklok/secret_scanning",
      "shortFailureMessage": "Secret scanning is not enabled",
      "context": {
        "provider": "",
        "project": "264d58cd-8746-47f3-b29c-48a98889f8b9"
      },
      "def": {
        "inEntity": "repository",
        "ruleSchema": {
          "properties": {
            "enabled": {
              "default": true,
              "type": "boolean"
            },
            "skip_private_repos": {
              "default": true,
              "description": "If true, this rule will be marked as skipped for private repositories\n",
              "type": "boolean"
            }
          }
        },
        "ingest": {
          "type": "rest",
          "rest": {
            "endpoint": "/repos/{{.Entity.Owner}}/{{.Entity.Name}}",
            "method": "",
            "headers": [],
            "parse": "json",
            "fallback": []
          }
        },
        "eval": {
          "type": "rego",
          "jq": [],
          "rego": {
            "type": "deny-by-default",
            "def": "package minder\n\nimport future.keywords.if\n\ndefault allow := false\ndefault skip := false\n\nallow if {\n  input.profile.enabled\n  input.ingested.security_and_analysis.secret_scanning.status == \"enabled\"\n}\n\nallow if {\n  not input.profile.enabled\n  input.ingested.security_and_analysis.secret_scanning.status == \"disabled\"\n}\n\nskip if {\n  input.profile.skip_private_repos == true\n  input.ingested.private == true\n}\n"
          }
        },
        "remediate": {
          "type": "rest",
          "rest": {
            "endpoint": "/repos/{{.Entity.Owner}}/{{.Entity.Name}}",
            "method": "PATCH",
            "headers": [],
            "body": "{{- if .Profile.enabled }}\n{ \"security_and_analysis\": {\"secret_scanning\": { \"status\": \"enabled\" } } }\n{{- else }}\n{ \"security_and_analysis\": {\"secret_scanning\": { \"status\": \"disabled\" } } }\n{{- end }}\n",
            "parse": "",
            "fallback": []
          }
        },
        "alert": {
          "type": "security_advisory",
          "securityAdvisory": {
            "severity": ""
          }
        }
      },
      "description": "Verifies that secret scanning is enabled for a given repository.\nNote that this will will not work as expected for private repositories\nunless you have GitHub Advanced Security enabled. If you still want to use\nthis rule because you have a mixture of private and public repositories,\nenable the `skip_private_repos` flag.\n",
      "guidance": "Ensure that secret scanning is enabled for the repository.\n\nSecret scanning is a feature that scans repositories for secrets and alerts\nthe repository owner when a secret is found. To enable this feature in GitHub,\nyou must enable it in the repository settings.\n\nFor more information, see\nhttps://docs.github.com/en/github/administering-a-repository/about-secret-scanning\n",
      "severity": {
        "value": "VALUE_HIGH"
      },
      "releasePhase": "RULE_TYPE_RELEASE_PHASE_ALPHA"
    },
    {
      "id": "2b418961-0e2b-465b-b738-48413e1ebaf7",
      "name": "stacklok/pr_trusty_check",
      "displayName": "Ensure pull requests do not add dependencies with a low Trusty score",
      "shortFailureMessage": "PR adds dependencies with low Trusty scores",
      "context": {
        "provider": "",
        "project": "11e34af0-f8b3-416d-9db0-6a04f499ca3f"
      },
      "def": {
        "inEntity": "pull_request",
        "ruleSchema": {
          "properties": {
            "action": {
              "default": "review",
              "description": "The action to take if a package with a low score is found.",
              "enum": ["profile_only", "review", "summary"],
              "type": "string"
            },
            "ecosystem_config": {
              "description": "The configuration for the ecosystems to check. Leave empty to use the default configuration.",
              "items": {
                "properties": {
                  "activity": {
                    "default": 0,
                    "description": "Minimum level of activity to consider as healthy. Values are 0-10 where 10 represents the most active.",
                    "type": "number"
                  },
                  "allow_malicious": {
                    "default": false,
                    "description": "Don't block PRs when malicious packages are found (not recommended)",
                    "type": "boolean"
                  },
                  "name": {
                    "description": "The name of the ecosystem to check. Currently only `go`, `npm` and `pypi` are supported.",
                    "type": "string"
                  },
                  "provenance": {
                    "default": 0,
                    "description": "Minimum provenance score to consider. Values are 0-10 where 10 represents the highest confidence in the computed origin of the package.",
                    "type": "number"
                  },
                  "score": {
                    "default": 5,
                    "description": "The minimum Trusty score for a dependency to be considered safe.",
                    "type": "number"
                  }
                },
                "type": "object"
              },
              "type": "array"
            }
          },
          "type": "object"
        },
        "ingest": {
          "type": "diff",
          "diff": {
            "ecosystems": [
              {
                "name": "npm",
                "depfile": "package-lock.json"
              },
              {
                "name": "pypi",
                "depfile": "requirements.txt"
              },
              {
                "name": "go",
                "depfile": "go.mod"
              }
            ],
            "type": ""
          }
        },
        "eval": {
          "type": "trusty",
          "jq": []
        },
        "alert": {
          "type": "security_advisory",
          "securityAdvisory": {
            "severity": ""
          }
        }
      },
      "description": "Verifies that pull requests do not add any dependencies with low Trusty scores\\n\\nFor every pull request submitted to a repository, this rule will check if the pull request\\nadds a new dependency with a low Trusty score. If a dependency with a low\\nscore is added, the PR will be commented on.\\n",
      "guidance": "Ensure that the pull request does not add any dependencies with low Trusty scores."
    }
  ]
}
