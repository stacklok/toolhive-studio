// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl: `${string}://${string}` | (string & {})
}

/**
 * DEPRECATED: Middleware configuration.
 * AuditConfig contains the audit logging configuration
 */
export type AuditConfig = {
  /**
   * Component is the component name to use in audit events.
   * +optional
   */
  component?: string
  /**
   * Enabled controls whether audit logging is enabled.
   * When true, enables audit logging with the configured options.
   * +kubebuilder:default=false
   * +optional
   */
  enabled?: boolean
  /**
   * EventTypes specifies which event types to audit. If empty, all events are audited.
   * +optional
   */
  eventTypes?: Array<string>
  /**
   * ExcludeEventTypes specifies which event types to exclude from auditing.
   * This takes precedence over EventTypes.
   * +optional
   */
  excludeEventTypes?: Array<string>
  /**
   * IncludeRequestData determines whether to include request data in audit logs.
   * +kubebuilder:default=false
   * +optional
   */
  includeRequestData?: boolean
  /**
   * IncludeResponseData determines whether to include response data in audit logs.
   * +kubebuilder:default=false
   * +optional
   */
  includeResponseData?: boolean
  /**
   * LogFile specifies the file path for audit logs. If empty, logs to stdout.
   * +optional
   */
  logFile?: string
  /**
   * MaxDataSize limits the size of request/response data included in audit logs (in bytes).
   * +kubebuilder:default=1024
   * +optional
   */
  maxDataSize?: number
}

/**
 * DEPRECATED: Middleware configuration.
 * OIDCConfig contains OIDC configuration
 */
export type AuthTokenValidatorConfig = {
  /**
   * AllowPrivateIP allows JWKS/OIDC endpoints on private IP addresses
   */
  allowPrivateIP?: boolean
  /**
   * Audience is the expected audience for the token
   */
  audience?: string
  /**
   * AuthTokenFile is the path to file containing bearer token for authentication
   */
  authTokenFile?: string
  /**
   * CACertPath is the path to the CA certificate bundle for HTTPS requests
   */
  cacertPath?: string
  /**
   * ClientID is the OIDC client ID
   */
  clientID?: string
  /**
   * ClientSecret is the optional OIDC client secret for introspection
   */
  clientSecret?: string
  /**
   * InsecureAllowHTTP allows HTTP (non-HTTPS) OIDC issuers for development/testing
   * WARNING: This is insecure and should NEVER be used in production
   */
  insecureAllowHTTP?: boolean
  /**
   * IntrospectionURL is the optional introspection endpoint for validating tokens
   */
  introspectionURL?: string
  /**
   * Issuer is the OIDC issuer URL (e.g., https://accounts.google.com)
   */
  issuer?: string
  /**
   * JWKSURL is the URL to fetch the JWKS from
   */
  jwksurl?: string
  /**
   * ResourceURL is the explicit resource URL for OAuth discovery (RFC 9728)
   */
  resourceURL?: string
  /**
   * Scopes is the list of OAuth scopes to advertise in the well-known endpoint (RFC 9728)
   * If empty, defaults to ["openid"]
   */
  scopes?: Array<string>
}

/**
 * OAuth2Config contains OAuth 2.0-specific configuration.
 * Required when Type is "oauth2", must be nil when Type is "oidc".
 */
export type AuthserverOAuth2UpstreamRunConfig = {
  /**
   * AuthorizationEndpoint is the URL for the OAuth authorization endpoint.
   */
  authorization_endpoint?: string
  /**
   * ClientID is the OAuth 2.0 client identifier registered with the upstream IDP.
   */
  client_id?: string
  /**
   * ClientSecretEnvVar is the name of an environment variable containing the client secret.
   * Mutually exclusive with ClientSecretFile. Optional for public clients using PKCE.
   */
  client_secret_env_var?: string
  /**
   * ClientSecretFile is the path to a file containing the OAuth 2.0 client secret.
   * Mutually exclusive with ClientSecretEnvVar. Optional for public clients using PKCE.
   */
  client_secret_file?: string
  /**
   * RedirectURI is the callback URL where the upstream IDP will redirect after authentication.
   * When not specified, defaults to `{issuer}/oauth/callback`.
   */
  redirect_uri?: string
  /**
   * Scopes are the OAuth scopes to request from the upstream IDP.
   */
  scopes?: Array<string>
  /**
   * TokenEndpoint is the URL for the OAuth token endpoint.
   */
  token_endpoint?: string
  userinfo?: AuthserverUserInfoRunConfig
}

/**
 * OIDCConfig contains OIDC-specific configuration.
 * Required when Type is "oidc", must be nil when Type is "oauth2".
 */
export type AuthserverOidcUpstreamRunConfig = {
  /**
   * ClientID is the OAuth 2.0 client identifier registered with the upstream IDP.
   */
  client_id?: string
  /**
   * ClientSecretEnvVar is the name of an environment variable containing the client secret.
   * Mutually exclusive with ClientSecretFile. Optional for public clients using PKCE.
   */
  client_secret_env_var?: string
  /**
   * ClientSecretFile is the path to a file containing the OAuth 2.0 client secret.
   * Mutually exclusive with ClientSecretEnvVar. Optional for public clients using PKCE.
   */
  client_secret_file?: string
  /**
   * IssuerURL is the OIDC issuer URL for automatic endpoint discovery.
   * Must be a valid HTTPS URL.
   */
  issuer_url?: string
  /**
   * RedirectURI is the callback URL where the upstream IDP will redirect after authentication.
   * When not specified, defaults to `{issuer}/oauth/callback`.
   */
  redirect_uri?: string
  /**
   * Scopes are the OAuth scopes to request from the upstream IDP.
   * If not specified, defaults to ["openid", "offline_access"].
   */
  scopes?: Array<string>
  userinfo_override?: AuthserverUserInfoRunConfig
}

/**
 * EmbeddedAuthServerConfig contains configuration for the embedded OAuth2/OIDC authorization server.
 * When set, the proxy runner will start an embedded auth server that delegates to upstream IDPs.
 * This is the serializable RunConfig; secrets are referenced by file paths or env var names.
 */
export type AuthserverRunConfig = {
  /**
   * AllowedAudiences is the list of valid resource URIs that tokens can be issued for.
   * Per RFC 8707, the "resource" parameter in authorization and token requests is
   * validated against this list. Required for MCP compliance.
   */
  allowed_audiences?: Array<string>
  /**
   * HMACSecretFiles contains file paths to HMAC secrets for signing authorization codes
   * and refresh tokens (opaque tokens).
   * First file is the current secret (must be at least 32 bytes), subsequent files
   * are for rotation/verification of existing tokens.
   * If empty, an ephemeral secret will be auto-generated (development only).
   */
  hmac_secret_files?: Array<string>
  /**
   * Issuer is the issuer identifier for this authorization server.
   * This will be included in the "iss" claim of issued tokens.
   * Must be a valid HTTPS URL (or HTTP for localhost) without query, fragment, or trailing slash.
   */
  issuer?: string
  /**
   * SchemaVersion is the version of the RunConfig schema.
   */
  schema_version?: string
  /**
   * ScopesSupported lists the OAuth 2.0 scope values advertised in discovery documents.
   * If empty, defaults to ["openid", "profile", "email", "offline_access"].
   */
  scopes_supported?: Array<string>
  signing_key_config?: AuthserverSigningKeyRunConfig
  token_lifespans?: AuthserverTokenLifespanRunConfig
  /**
   * Upstreams configures connections to upstream Identity Providers.
   * At least one upstream is required - the server delegates authentication to these providers.
   * Currently only a single upstream is supported.
   */
  upstreams?: Array<AuthserverUpstreamRunConfig>
}

/**
 * SigningKeyConfig configures the signing key provider for JWT operations.
 * If nil or empty, an ephemeral signing key will be auto-generated (development only).
 */
export type AuthserverSigningKeyRunConfig = {
  /**
   * FallbackKeyFiles are filenames of additional keys for verification (relative to KeyDir).
   * These keys are included in the JWKS endpoint for token verification but are NOT
   * used for signing new tokens. Useful for key rotation.
   */
  fallback_key_files?: Array<string>
  /**
   * KeyDir is the directory containing PEM-encoded private key files.
   * All key filenames are relative to this directory.
   * In Kubernetes, this is typically a mounted Secret volume.
   */
  key_dir?: string
  /**
   * SigningKeyFile is the filename of the primary signing key (relative to KeyDir).
   * This key is used for signing new tokens.
   */
  signing_key_file?: string
}

/**
 * TokenLifespans configures the duration that various tokens are valid.
 * If nil, defaults are applied (access: 1h, refresh: 7d, authCode: 10m).
 */
export type AuthserverTokenLifespanRunConfig = {
  /**
   * AccessTokenLifespan is the duration that access tokens are valid.
   * If empty, defaults to 1 hour.
   */
  access_token_lifespan?: string
  /**
   * AuthCodeLifespan is the duration that authorization codes are valid.
   * If empty, defaults to 10 minutes.
   */
  auth_code_lifespan?: string
  /**
   * RefreshTokenLifespan is the duration that refresh tokens are valid.
   * If empty, defaults to 7 days (168h).
   */
  refresh_token_lifespan?: string
}

/**
 * Type specifies the provider type: "oidc" or "oauth2".
 */
export type AuthserverUpstreamProviderType = 'oidc' | 'oauth2'

export type AuthserverUpstreamRunConfig = {
  /**
   * Name uniquely identifies this upstream.
   * Used for routing decisions and session binding in multi-upstream scenarios.
   * If empty when only one upstream is configured, defaults to "default".
   */
  name?: string
  oauth2_config?: AuthserverOAuth2UpstreamRunConfig
  oidc_config?: AuthserverOidcUpstreamRunConfig
  type?: AuthserverUpstreamProviderType
}

/**
 * FieldMapping contains custom field mapping configuration for non-standard providers.
 * If nil, standard OIDC field names are used ("sub", "name", "email").
 */
export type AuthserverUserInfoFieldMappingRunConfig = {
  /**
   * EmailFields is an ordered list of field names to try for the email address.
   * The first non-empty value found will be used.
   * Default: ["email"]
   */
  email_fields?: Array<string>
  /**
   * NameFields is an ordered list of field names to try for the display name.
   * The first non-empty value found will be used.
   * Default: ["name"]
   */
  name_fields?: Array<string>
  /**
   * SubjectFields is an ordered list of field names to try for the user ID.
   * The first non-empty value found will be used.
   * Default: ["sub"]
   */
  subject_fields?: Array<string>
}

/**
 * UserInfo contains configuration for fetching user information (required for OAuth2).
 */
export type AuthserverUserInfoRunConfig = {
  /**
   * AdditionalHeaders contains extra headers to include in the userinfo request.
   * Useful for providers that require specific headers (e.g., GitHub's Accept header).
   */
  additional_headers?: {
    [key: string]: string
  }
  /**
   * EndpointURL is the URL of the userinfo endpoint.
   */
  endpoint_url?: string
  field_mapping?: AuthserverUserInfoFieldMappingRunConfig
  /**
   * HTTPMethod is the HTTP method to use for the userinfo request.
   * If not specified, defaults to GET.
   */
  http_method?: string
}

/**
 * DEPRECATED: Middleware configuration.
 * AuthzConfig contains the authorization configuration
 */
export type AuthzConfig = {
  /**
   * Type is the type of authorization configuration (e.g., "cedarv1").
   */
  type?: string
  /**
   * Version is the version of the configuration format.
   */
  version?: string
}

/**
 * AWSStsConfig contains AWS STS token exchange configuration for accessing AWS services
 */
export type AwsstsConfig = {
  /**
   * FallbackRoleArn is the IAM role ARN to assume when no role mapping matches.
   */
  fallback_role_arn?: string
  /**
   * Region is the AWS region for STS and SigV4 signing.
   */
  region?: string
  /**
   * RoleClaim is the JWT claim to use for role mapping (default: "groups").
   */
  role_claim?: string
  /**
   * RoleMappings maps JWT claim values to IAM roles with priority.
   */
  role_mappings?: Array<AwsstsRoleMapping>
  /**
   * Service is the AWS service name for SigV4 signing (default: "aws-mcp").
   */
  service?: string
  /**
   * SessionDuration is the duration in seconds for assumed role credentials (default: 3600).
   */
  session_duration?: number
  /**
   * SessionNameClaim is the JWT claim to use for role session name (default: "sub").
   */
  session_name_claim?: string
}

export type AwsstsRoleMapping = {
  /**
   * Claim is the simple claim value to match (e.g., group name).
   * Internally compiles to a CEL expression: "<claim_value>" in claims["<role_claim>"]
   * Mutually exclusive with Matcher.
   */
  claim?: string
  /**
   * Matcher is a CEL expression for complex matching against JWT claims.
   * The expression has access to a "claims" variable containing all JWT claims.
   * Examples:
   * - "admins" in claims["groups"]
   * - claims["sub"] == "user123" && !("act" in claims)
   * Mutually exclusive with Claim.
   */
  matcher?: string
  /**
   * Priority determines selection order (lower number = higher priority).
   * When multiple mappings match, the one with the lowest priority is selected.
   * When nil (omitted), the mapping has the lowest possible priority, and
   * configuration order acts as tie-breaker via stable sort.
   */
  priority?: number
  /**
   * RoleArn is the IAM role ARN to assume when this mapping matches.
   */
  role_arn?: string
}

/**
 * ClientType is the type of MCP client
 */
export type ClientClientApp =
  | 'roo-code'
  | 'cline'
  | 'cursor'
  | 'vscode-insider'
  | 'vscode'
  | 'claude-code'
  | 'windsurf'
  | 'windsurf-jetbrains'
  | 'amp-cli'
  | 'amp-vscode'
  | 'amp-cursor'
  | 'amp-vscode-insider'
  | 'amp-windsurf'
  | 'lm-studio'
  | 'goose'
  | 'trae'
  | 'continue'
  | 'opencode'
  | 'kiro'
  | 'antigravity'
  | 'zed'
  | 'gemini-cli'
  | 'vscode-server'
  | 'mistral-vibe'
  | 'codex'

export type ClientClientAppStatus = {
  client_type?: ClientClientApp
  /**
   * Installed indicates whether the client is installed on the system
   */
  installed?: boolean
  /**
   * Registered indicates whether the client is registered in the ToolHive configuration
   */
  registered?: boolean
}

export type ClientRegisteredClient = {
  groups?: Array<string>
  name?: ClientClientApp
}

export type CoreWorkload = {
  /**
   * CreatedAt is the timestamp when the workload was created.
   */
  created_at?: string
  /**
   * Group is the name of the group this workload belongs to, if any.
   */
  group?: string
  /**
   * Labels are the container labels (excluding standard ToolHive labels)
   */
  labels?: {
    [key: string]: string
  }
  /**
   * Name is the name of the workload.
   * It is used as a unique identifier.
   */
  name?: string
  /**
   * Package specifies the Workload Package used to create this Workload.
   */
  package?: string
  /**
   * Port is the port on which the workload is exposed.
   * This is embedded in the URL.
   */
  port?: number
  /**
   * ProxyMode is the proxy mode that clients should use to connect.
   * For stdio transports, this will be the proxy mode (sse or streamable-http).
   * For direct transports (sse/streamable-http), this will be the same as TransportType.
   */
  proxy_mode?: string
  /**
   * Remote indicates whether this is a remote workload (true) or a container workload (false).
   */
  remote?: boolean
  /**
   * StartedAt is when the container was last started (changes on restart)
   */
  started_at?: string
  status?: RuntimeWorkloadStatus
  /**
   * StatusContext provides additional context about the workload's status.
   * The exact meaning is determined by the status and the underlying runtime.
   */
  status_context?: string
  /**
   * ToolsFilter is the filter on tools applied to the workload.
   */
  tools?: Array<string>
  transport_type?: TypesTransportType
  /**
   * URL is the URL of the workload exposed by the ToolHive proxy.
   */
  url?: string
}

export type GroupsGroup = {
  name?: string
  registered_clients?: Array<string>
}

/**
 * IgnoreConfig contains configuration for ignore processing
 */
export type IgnoreConfig = {
  /**
   * Whether to load global ignore patterns
   */
  loadGlobal?: boolean
  /**
   * Whether to print resolved overlay paths for debugging
   */
  printOverlays?: boolean
}

/**
 * Inbound defines inbound network permissions
 */
export type PermissionsInboundNetworkPermissions = {
  /**
   * AllowHost is a list of allowed hosts for inbound connections
   */
  allow_host?: Array<string>
}

/**
 * Network defines network permissions
 */
export type PermissionsNetworkPermissions = {
  inbound?: PermissionsInboundNetworkPermissions
  /**
   * Mode specifies the network mode for the container (e.g., "host", "bridge", "none")
   * When empty, the default container runtime network mode is used
   */
  mode?: string
  outbound?: PermissionsOutboundNetworkPermissions
}

/**
 * Outbound defines outbound network permissions
 */
export type PermissionsOutboundNetworkPermissions = {
  /**
   * AllowHost is a list of allowed hosts
   */
  allow_host?: Array<string>
  /**
   * AllowPort is a list of allowed ports
   */
  allow_port?: Array<number>
  /**
   * InsecureAllowAll allows all outbound network connections
   */
  insecure_allow_all?: boolean
}

/**
 * PermissionProfile is the permission profile to use
 */
export type PermissionsProfile = {
  /**
   * Name is the name of the profile
   */
  name?: string
  network?: PermissionsNetworkPermissions
  /**
   * Privileged indicates whether the container should run in privileged mode
   * When true, the container has access to all host devices and capabilities
   * Use with extreme caution as this removes most security isolation
   */
  privileged?: boolean
  /**
   * Read is a list of mount declarations that the container can read from
   * These can be in the following formats:
   * - A single path: The same path will be mounted from host to container
   * - host-path:container-path: Different paths for host and container
   * - resource-uri:container-path: Mount a resource identified by URI to a container path
   */
  read?: Array<string>
  /**
   * Write is a list of mount declarations that the container can write to
   * These follow the same format as Read mounts but with write permissions
   */
  write?: Array<string>
}

export type RegistryEnvVar = {
  /**
   * Default is the value to use if the environment variable is not explicitly provided
   * Only used for non-required variables
   */
  default?: string
  /**
   * Description is a human-readable explanation of the variable's purpose
   */
  description?: string
  /**
   * Name is the environment variable name (e.g., API_KEY)
   */
  name?: string
  /**
   * Required indicates whether this environment variable must be provided
   * If true and not provided via command line or secrets, the user will be prompted for a value
   */
  required?: boolean
  /**
   * Secret indicates whether this environment variable contains sensitive information
   * If true, the value will be stored as a secret rather than as a plain environment variable
   */
  secret?: boolean
}

export type RegistryGroup = {
  /**
   * Description is a human-readable description of the group's purpose and functionality
   */
  description?: string
  /**
   * Name is the identifier for the group, used when referencing the group in commands
   */
  name?: string
  /**
   * RemoteServers is a map of server names to their corresponding remote server definitions within this group
   */
  remote_servers?: {
    [key: string]: RegistryRemoteServerMetadata
  }
  /**
   * Servers is a map of server names to their corresponding server definitions within this group
   */
  servers?: {
    [key: string]: RegistryImageMetadata
  }
}

export type RegistryHeader = {
  /**
   * Choices provides a list of valid values for the header (optional)
   */
  choices?: Array<string>
  /**
   * Default is the value to use if the header is not explicitly provided
   * Only used for non-required headers
   */
  default?: string
  /**
   * Description is a human-readable explanation of the header's purpose
   */
  description?: string
  /**
   * Name is the header name (e.g., X-API-Key, Authorization)
   */
  name?: string
  /**
   * Required indicates whether this header must be provided
   * If true and not provided via command line or secrets, the user will be prompted for a value
   */
  required?: boolean
  /**
   * Secret indicates whether this header contains sensitive information
   * If true, the value will be stored as a secret rather than as plain text
   */
  secret?: boolean
}

/**
 * Container server details (if it's a container server)
 */
export type RegistryImageMetadata = {
  /**
   * Args are the default command-line arguments to pass to the MCP server container.
   * These arguments will be used only if no command-line arguments are provided by the user.
   * If the user provides arguments, they will override these defaults.
   */
  args?: Array<string>
  /**
   * CustomMetadata allows for additional user-defined metadata
   */
  custom_metadata?: {
    [key: string]: unknown
  }
  /**
   * Description is a human-readable description of the server's purpose and functionality
   */
  description?: string
  /**
   * DockerTags lists the available Docker tags for this server image
   */
  docker_tags?: Array<string>
  /**
   * EnvVars defines environment variables that can be passed to the server
   */
  env_vars?: Array<RegistryEnvVar>
  /**
   * Image is the Docker image reference for the MCP server
   */
  image?: string
  metadata?: RegistryMetadata
  /**
   * Name is the identifier for the MCP server, used when referencing the server in commands
   * If not provided, it will be auto-generated from the registry key
   */
  name?: string
  permissions?: PermissionsProfile
  provenance?: RegistryProvenance
  /**
   * ProxyPort is the port for the HTTP proxy to listen on (host port)
   * If not specified, a random available port will be assigned
   */
  proxy_port?: number
  /**
   * RepositoryURL is the URL to the source code repository for the server
   */
  repository_url?: string
  /**
   * Status indicates whether the server is currently active or deprecated
   */
  status?: string
  /**
   * Tags are categorization labels for the server to aid in discovery and filtering
   */
  tags?: Array<string>
  /**
   * TargetPort is the port for the container to expose (only applicable to SSE and Streamable HTTP transports)
   */
  target_port?: number
  /**
   * Tier represents the tier classification level of the server, e.g., "Official" or "Community"
   */
  tier?: string
  /**
   * Tools is a list of tool names provided by this MCP server
   */
  tools?: Array<string>
  /**
   * Transport defines the communication protocol for the server
   * For containers: stdio, sse, or streamable-http
   * For remote servers: sse or streamable-http (stdio not supported)
   */
  transport?: string
}

/**
 * Kubernetes contains Kubernetes-specific metadata when the MCP server is deployed in a cluster.
 * This field is optional and only populated when:
 * - The server is served from ToolHive Registry Server
 * - The server was auto-discovered from a Kubernetes deployment
 * - The Kubernetes resource has the required registry annotations
 */
export type RegistryKubernetesMetadata = {
  /**
   * Image is the container image used by the Kubernetes workload (applicable to MCPServer)
   */
  image?: string
  /**
   * Kind is the Kubernetes resource kind (e.g., MCPServer, VirtualMCPServer, MCPRemoteProxy)
   */
  kind?: string
  /**
   * Name is the Kubernetes resource name
   */
  name?: string
  /**
   * Namespace is the Kubernetes namespace where the resource is deployed
   */
  namespace?: string
  /**
   * Transport is the transport type configured for the Kubernetes workload (applicable to MCPServer)
   */
  transport?: string
  /**
   * UID is the Kubernetes resource UID
   */
  uid?: string
}

/**
 * Metadata contains additional information about the server such as popularity metrics
 */
export type RegistryMetadata = {
  kubernetes?: RegistryKubernetesMetadata
  /**
   * LastUpdated is the timestamp when the server was last updated, in RFC3339 format
   */
  last_updated?: string
  /**
   * Pulls indicates how many times the server image has been downloaded
   */
  pulls?: number
  /**
   * Stars represents the popularity rating or number of stars for the server
   */
  stars?: number
}

/**
 * OAuthConfig provides OAuth/OIDC configuration for authentication to the remote server
 * Used with the thv proxy command's --remote-auth flags
 */
export type RegistryOAuthConfig = {
  /**
   * AuthorizeURL is the OAuth authorization endpoint URL
   * Used for non-OIDC OAuth flows when issuer is not provided
   */
  authorize_url?: string
  /**
   * CallbackPort is the specific port to use for the OAuth callback server
   * If not specified, a random available port will be used
   */
  callback_port?: number
  /**
   * ClientID is the OAuth client ID for authentication
   */
  client_id?: string
  /**
   * Issuer is the OAuth/OIDC issuer URL (e.g., https://accounts.google.com)
   * Used for OIDC discovery to find authorization and token endpoints
   */
  issuer?: string
  /**
   * OAuthParams contains additional OAuth parameters to include in the authorization request
   * These are server-specific parameters like "prompt", "response_mode", etc.
   */
  oauth_params?: {
    [key: string]: string
  }
  /**
   * Resource is the OAuth 2.0 resource indicator (RFC 8707)
   */
  resource?: string
  /**
   * Scopes are the OAuth scopes to request
   * If not specified, defaults to ["openid", "profile", "email"] for OIDC
   */
  scopes?: Array<string>
  /**
   * TokenURL is the OAuth token endpoint URL
   * Used for non-OIDC OAuth flows when issuer is not provided
   */
  token_url?: string
  /**
   * UsePKCE indicates whether to use PKCE for the OAuth flow
   * Defaults to true for enhanced security
   */
  use_pkce?: boolean
}

/**
 * Provenance contains verification and signing metadata
 */
export type RegistryProvenance = {
  attestation?: RegistryVerifiedAttestation
  cert_issuer?: string
  repository_ref?: string
  repository_uri?: string
  runner_environment?: string
  signer_identity?: string
  sigstore_url?: string
}

/**
 * Full registry data
 */
export type RegistryRegistry = {
  /**
   * Groups is a slice of group definitions containing related MCP servers
   */
  groups?: Array<RegistryGroup>
  /**
   * LastUpdated is the timestamp when the registry was last updated, in RFC3339 format
   */
  last_updated?: string
  /**
   * RemoteServers is a map of server names to their corresponding remote server definitions
   * These are MCP servers accessed via HTTP/HTTPS using the thv proxy command
   */
  remote_servers?: {
    [key: string]: RegistryRemoteServerMetadata
  }
  /**
   * Servers is a map of server names to their corresponding server definitions
   */
  servers?: {
    [key: string]: RegistryImageMetadata
  }
  /**
   * Version is the schema version of the registry
   */
  version?: string
}

/**
 * Remote server details (if it's a remote server)
 */
export type RegistryRemoteServerMetadata = {
  /**
   * CustomMetadata allows for additional user-defined metadata
   */
  custom_metadata?: {
    [key: string]: unknown
  }
  /**
   * Description is a human-readable description of the server's purpose and functionality
   */
  description?: string
  /**
   * EnvVars defines environment variables that can be passed to configure the client
   * These might be needed for client-side configuration when connecting to the remote server
   */
  env_vars?: Array<RegistryEnvVar>
  /**
   * Headers defines HTTP headers that can be passed to the remote server for authentication
   * These are used with the thv proxy command's authentication features
   */
  headers?: Array<RegistryHeader>
  metadata?: RegistryMetadata
  /**
   * Name is the identifier for the MCP server, used when referencing the server in commands
   * If not provided, it will be auto-generated from the registry key
   */
  name?: string
  oauth_config?: RegistryOAuthConfig
  /**
   * RepositoryURL is the URL to the source code repository for the server
   */
  repository_url?: string
  /**
   * Status indicates whether the server is currently active or deprecated
   */
  status?: string
  /**
   * Tags are categorization labels for the server to aid in discovery and filtering
   */
  tags?: Array<string>
  /**
   * Tier represents the tier classification level of the server, e.g., "Official" or "Community"
   */
  tier?: string
  /**
   * Tools is a list of tool names provided by this MCP server
   */
  tools?: Array<string>
  /**
   * Transport defines the communication protocol for the server
   * For containers: stdio, sse, or streamable-http
   * For remote servers: sse or streamable-http (stdio not supported)
   */
  transport?: string
  /**
   * URL is the endpoint URL for the remote MCP server (e.g., https://api.example.com/mcp)
   */
  url?: string
}

export type RegistryVerifiedAttestation = {
  predicate?: unknown
  predicate_type?: string
}

/**
 * RemoteAuthConfig contains OAuth configuration for remote MCP servers
 */
export type RemoteConfig = {
  authorize_url?: string
  /**
   * Bearer token configuration (alternative to OAuth)
   */
  bearer_token?: string
  bearer_token_file?: string
  /**
   * Cached DCR client credentials for persistence across restarts.
   * These are obtained during Dynamic Client Registration and needed to refresh tokens.
   * ClientID is stored as plain text since it's public information.
   */
  cached_client_id?: string
  cached_client_secret_ref?: string
  /**
   * Cached OAuth token reference for persistence across restarts.
   * The refresh token is stored securely in the secret manager, and this field
   * contains the reference to retrieve it (e.g., "OAUTH_REFRESH_TOKEN_workload").
   * This enables session restoration without requiring a new browser-based login.
   */
  cached_refresh_token_ref?: string
  /**
   * RegistrationAccessToken is used to update/delete the client registration.
   * Stored as a secret reference since it's sensitive.
   */
  cached_reg_token_ref?: string
  /**
   * ClientSecretExpiresAt indicates when the client secret expires (if provided by the DCR server).
   * A zero value means the secret does not expire.
   */
  cached_secret_expiry?: string
  cached_token_expiry?: string
  callback_port?: number
  client_id?: string
  client_secret?: string
  client_secret_file?: string
  /**
   * Environment variables for the client
   */
  env_vars?: Array<RegistryEnvVar>
  /**
   * Headers for HTTP requests
   */
  headers?: Array<RegistryHeader>
  /**
   * OAuth endpoint configuration (from registry)
   */
  issuer?: string
  /**
   * OAuth parameters for server-specific customization
   */
  oauth_params?: {
    [key: string]: string
  }
  /**
   * Resource is the OAuth 2.0 resource indicator (RFC 8707).
   */
  resource?: string
  scopes?: Array<string>
  skip_browser?: boolean
  timeout?: string
  token_url?: string
  use_pkce?: boolean
}

/**
 * HeaderForward contains configuration for injecting headers into requests to remote servers.
 */
export type RunnerHeaderForwardConfig = {
  /**
   * AddHeadersFromSecret is a map of header names to secret names.
   * The key is the header name, the value is the secret name in ToolHive's secrets manager.
   * Resolved at runtime via WithSecrets() into resolvedHeaders.
   * The actual secret value is only held in memory, never persisted.
   */
  add_headers_from_secret?: {
    [key: string]: string
  }
  /**
   * AddPlaintextHeaders is a map of header names to literal values to inject into requests.
   * WARNING: These values are stored in plaintext in the configuration.
   * For sensitive values (API keys, tokens), use AddHeadersFromSecret instead.
   */
  add_plaintext_headers?: {
    [key: string]: string
  }
}

export type RunnerRunConfig = {
  audit_config?: AuditConfig
  /**
   * DEPRECATED: Middleware configuration.
   * AuditConfigPath is the path to the audit configuration file
   */
  audit_config_path?: string
  authz_config?: AuthzConfig
  /**
   * DEPRECATED: Middleware configuration.
   * AuthzConfigPath is the path to the authorization configuration file
   */
  authz_config_path?: string
  aws_sts_config?: AwsstsConfig
  /**
   * BaseName is the base name used for the container (without prefixes)
   */
  base_name?: string
  /**
   * CmdArgs are the arguments to pass to the container
   */
  cmd_args?: Array<string>
  /**
   * ContainerLabels are the labels to apply to the container
   */
  container_labels?: {
    [key: string]: string
  }
  /**
   * ContainerName is the name of the container
   */
  container_name?: string
  /**
   * Debug indicates whether debug mode is enabled
   */
  debug?: boolean
  embedded_auth_server_config?: AuthserverRunConfig
  /**
   * EndpointPrefix is an explicit prefix to prepend to SSE endpoint URLs.
   * This is used to handle path-based ingress routing scenarios.
   */
  endpoint_prefix?: string
  /**
   * DEPRECATED: No longer appears to be used.
   * EnvFileDir is the directory path to load environment files from
   */
  env_file_dir?: string
  /**
   * EnvVars are the parsed environment variables as key-value pairs
   */
  env_vars?: {
    [key: string]: string
  }
  /**
   * Group is the name of the group this workload belongs to, if any
   */
  group?: string
  header_forward?: RunnerHeaderForwardConfig
  /**
   * Host is the host for the HTTP proxy
   */
  host?: string
  ignore_config?: IgnoreConfig
  /**
   * Image is the Docker image to run
   */
  image?: string
  /**
   * IsolateNetwork indicates whether to isolate the network for the container
   */
  isolate_network?: boolean
  /**
   * DEPRECATED: No longer appears to be used.
   * JWKSAuthTokenFile is the path to file containing auth token for JWKS/OIDC requests
   */
  jwks_auth_token_file?: string
  /**
   * K8sPodTemplatePatch is a JSON string to patch the Kubernetes pod template
   * Only applicable when using Kubernetes runtime
   */
  k8s_pod_template_patch?: string
  /**
   * MiddlewareConfigs contains the list of middleware to apply to the transport
   * and the configuration for each middleware.
   */
  middleware_configs?: Array<TypesMiddlewareConfig>
  /**
   * Name is the name of the MCP server
   */
  name?: string
  oidc_config?: AuthTokenValidatorConfig
  permission_profile?: PermissionsProfile
  /**
   * PermissionProfileNameOrPath is the name or path of the permission profile
   */
  permission_profile_name_or_path?: string
  /**
   * Port is the port for the HTTP proxy to listen on (host port)
   */
  port?: number
  proxy_mode?: TypesProxyMode
  remote_auth_config?: RemoteConfig
  /**
   * RemoteURL is the URL of the remote MCP server (if running remotely)
   */
  remote_url?: string
  runtime_config?: TemplatesRuntimeConfig
  /**
   * SchemaVersion is the version of the RunConfig schema
   */
  schema_version?: string
  /**
   * Secrets are the secret parameters to pass to the container
   * Format: "<secret name>,target=<target environment variable>"
   */
  secrets?: Array<string>
  /**
   * TargetHost is the host to forward traffic to (only applicable to SSE transport)
   */
  target_host?: string
  /**
   * TargetPort is the port for the container to expose (only applicable to SSE transport)
   */
  target_port?: number
  telemetry_config?: TelemetryConfig
  /**
   * DEPRECATED: No longer appears to be used.
   * ThvCABundle is the path to the CA certificate bundle for ToolHive HTTP operations
   */
  thv_ca_bundle?: string
  token_exchange_config?: TokenexchangeConfig
  /**
   * DEPRECATED: Middleware configuration.
   * ToolsFilter is the list of tools to filter
   */
  tools_filter?: Array<string>
  /**
   * DEPRECATED: Middleware configuration.
   * ToolsOverride is a map from an actual tool to its overridden name and/or description
   */
  tools_override?: {
    [key: string]: RunnerToolOverride
  }
  transport?: TypesTransportType
  /**
   * TrustProxyHeaders indicates whether to trust X-Forwarded-* headers from reverse proxies
   */
  trust_proxy_headers?: boolean
  upstream_swap_config?: UpstreamswapConfig
  /**
   * Volumes are the directory mounts to pass to the container
   * Format: "host-path:container-path[:ro]"
   */
  volumes?: Array<string>
}

export type RunnerToolOverride = {
  /**
   * Description is the redefined description of the tool
   */
  description?: string
  /**
   * Name is the redefined name of the tool
   */
  name?: string
}

/**
 * Current status of the workload
 */
export type RuntimeWorkloadStatus =
  | 'running'
  | 'stopped'
  | 'error'
  | 'starting'
  | 'stopping'
  | 'unhealthy'
  | 'removing'
  | 'unknown'
  | 'unauthenticated'

/**
 * Bearer token for authentication (alternative to OAuth)
 */
export type SecretsSecretParameter = {
  name?: string
  target?: string
}

export type SkillsBuildResult = {
  /**
   * Reference is the OCI reference of the built skill artifact.
   */
  reference?: string
}

export type SkillsDependency = {
  /**
   * Digest is the OCI digest for upgrade detection.
   */
  digest?: string
  /**
   * Name is the dependency name.
   */
  name?: string
  /**
   * Reference is the OCI reference for the dependency.
   */
  reference?: string
}

/**
 * Status is the current installation status.
 */
export type SkillsInstallStatus = 'installed' | 'pending' | 'failed'

/**
 * InstalledSkill contains the full installation record.
 */
export type SkillsInstalledSkill = {
  /**
   * Clients is the list of client identifiers the skill is installed for.
   * TODO: Refactor client.ClientApp to a shared package so it can be used here instead of []string.
   */
  clients?: Array<string>
  /**
   * Dependencies is the list of external skill dependencies.
   */
  dependencies?: Array<SkillsDependency>
  /**
   * Digest is the OCI digest (sha256:...) for upgrade detection.
   */
  digest?: string
  /**
   * InstalledAt is the timestamp when the skill was installed.
   */
  installed_at?: string
  metadata?: SkillsSkillMetadata
  /**
   * ProjectRoot is the project root path for project-scoped skills. Empty for user-scoped.
   */
  project_root?: string
  /**
   * Reference is the full OCI reference (e.g. ghcr.io/org/skill:v1).
   */
  reference?: string
  scope?: SkillsScope
  status?: SkillsInstallStatus
  /**
   * Tag is the OCI tag (e.g. v1.0.0).
   */
  tag?: string
}

/**
 * Scope for the installation
 */
export type SkillsScope = 'user' | 'project'

export type SkillsSkillInfo = {
  installed_skill?: SkillsInstalledSkill
  metadata?: SkillsSkillMetadata
}

/**
 * Metadata contains the skill's metadata.
 */
export type SkillsSkillMetadata = {
  /**
   * Author is the skill author or maintainer.
   */
  author?: string
  /**
   * Description is a human-readable description of the skill.
   */
  description?: string
  /**
   * Name is the unique name of the skill.
   */
  name?: string
  /**
   * Tags is a list of tags for categorization.
   */
  tags?: Array<string>
  /**
   * Version is the semantic version of the skill.
   */
  version?: string
}

export type SkillsValidationResult = {
  /**
   * Errors is a list of validation errors, if any.
   */
  errors?: Array<string>
  /**
   * Valid indicates whether the skill definition is valid.
   */
  valid?: boolean
  /**
   * Warnings is a list of non-blocking validation warnings, if any.
   */
  warnings?: Array<string>
}

/**
 * DEPRECATED: Middleware configuration.
 * TelemetryConfig contains the OpenTelemetry configuration
 */
export type TelemetryConfig = {
  /**
   * CustomAttributes contains custom resource attributes to be added to all telemetry signals.
   * These are parsed from CLI flags (--otel-custom-attributes) or environment variables
   * (OTEL_RESOURCE_ATTRIBUTES) as key=value pairs.
   * +optional
   */
  customAttributes?: {
    [key: string]: string
  }
  /**
   * EnablePrometheusMetricsPath controls whether to expose Prometheus-style /metrics endpoint.
   * The metrics are served on the main transport port at /metrics.
   * This is separate from OTLP metrics which are sent to the Endpoint.
   * +kubebuilder:default=false
   * +optional
   */
  enablePrometheusMetricsPath?: boolean
  /**
   * Endpoint is the OTLP endpoint URL
   * +optional
   */
  endpoint?: string
  /**
   * EnvironmentVariables is a list of environment variable names that should be
   * included in telemetry spans as attributes. Only variables in this list will
   * be read from the host machine and included in spans for observability.
   * Example: ["NODE_ENV", "DEPLOYMENT_ENV", "SERVICE_VERSION"]
   * +optional
   */
  environmentVariables?: Array<string>
  /**
   * Headers contains authentication headers for the OTLP endpoint.
   * +optional
   */
  headers?: {
    [key: string]: string
  }
  /**
   * Insecure indicates whether to use HTTP instead of HTTPS for the OTLP endpoint.
   * +kubebuilder:default=false
   * +optional
   */
  insecure?: boolean
  /**
   * MetricsEnabled controls whether OTLP metrics are enabled.
   * When false, OTLP metrics are not sent even if an endpoint is configured.
   * This is independent of EnablePrometheusMetricsPath.
   * +kubebuilder:default=false
   * +optional
   */
  metricsEnabled?: boolean
  /**
   * SamplingRate is the trace sampling rate (0.0-1.0) as a string.
   * Only used when TracingEnabled is true.
   * Example: "0.05" for 5% sampling.
   * +kubebuilder:default="0.05"
   * +optional
   */
  samplingRate?: string
  /**
   * ServiceName is the service name for telemetry.
   * When omitted, defaults to the server name (e.g., VirtualMCPServer name).
   * +optional
   */
  serviceName?: string
  /**
   * ServiceVersion is the service version for telemetry.
   * When omitted, defaults to the ToolHive version.
   * +optional
   */
  serviceVersion?: string
  /**
   * TracingEnabled controls whether distributed tracing is enabled.
   * When false, no tracer provider is created even if an endpoint is configured.
   * +kubebuilder:default=false
   * +optional
   */
  tracingEnabled?: boolean
  /**
   * UseLegacyAttributes controls whether legacy (pre-MCP OTEL semconv) attribute names
   * are emitted alongside the new standard attribute names. When true, spans include both
   * old and new attribute names for backward compatibility with existing dashboards.
   * Currently defaults to true; this will change to false in a future release.
   * +kubebuilder:default=true
   * +optional
   */
  useLegacyAttributes?: boolean
}

/**
 * RuntimeConfig allows overriding the default runtime configuration
 * for this specific workload (base images and packages)
 */
export type TemplatesRuntimeConfig = {
  /**
   * AdditionalPackages lists extra packages to install in builder stage
   * Examples for Alpine: ["git", "make", "gcc"]
   * Examples for Debian: ["git", "build-essential"]
   */
  additional_packages?: Array<string>
  /**
   * BuilderImage is the full image reference for the builder stage
   * Examples: "golang:1.25-alpine", "node:22-alpine", "python:3.13-slim"
   */
  builder_image?: string
}

/**
 * TokenExchangeConfig contains token exchange configuration for external authentication
 */
export type TokenexchangeConfig = {
  /**
   * Audience is the target audience for the exchanged token
   */
  audience?: string
  /**
   * ClientID is the OAuth 2.0 client identifier
   */
  client_id?: string
  /**
   * ClientSecret is the OAuth 2.0 client secret
   */
  client_secret?: string
  /**
   * ExternalTokenHeaderName is the name of the custom header to use when HeaderStrategy is "custom"
   */
  external_token_header_name?: string
  /**
   * HeaderStrategy determines how to inject the token
   * Valid values: HeaderStrategyReplace (default), HeaderStrategyCustom
   */
  header_strategy?: string
  /**
   * Scopes is the list of scopes to request for the exchanged token
   */
  scopes?: Array<string>
  /**
   * SubjectTokenType specifies the type of the subject token being exchanged.
   * Common values: tokenTypeAccessToken (default), tokenTypeIDToken, tokenTypeJWT.
   * If empty, defaults to tokenTypeAccessToken.
   */
  subject_token_type?: string
  /**
   * TokenURL is the OAuth 2.0 token endpoint URL
   */
  token_url?: string
}

export type TypesMiddlewareConfig = {
  /**
   * Parameters is a JSON object containing the middleware parameters.
   * It is stored as a raw message to allow flexible parameter types.
   */
  parameters?: {
    [key: string]: unknown
  }
  /**
   * Type is a string representing the middleware type.
   */
  type?: string
}

/**
 * ProxyMode is the proxy mode for stdio transport ("sse" or "streamable-http")
 * Note: "sse" is deprecated; use "streamable-http" instead.
 */
export type TypesProxyMode = 'sse' | 'streamable-http'

/**
 * Transport is the transport mode (stdio, sse, or streamable-http)
 */
export type TypesTransportType =
  | 'stdio'
  | 'sse'
  | 'streamable-http'
  | 'inspector'

/**
 * UpstreamSwapConfig contains configuration for upstream token swap middleware.
 * When set along with EmbeddedAuthServerConfig, this middleware exchanges ToolHive JWTs
 * for upstream IdP tokens before forwarding requests to the MCP server.
 */
export type UpstreamswapConfig = {
  /**
   * CustomHeaderName is the header name when HeaderStrategy is "custom".
   */
  custom_header_name?: string
  /**
   * HeaderStrategy determines how to inject the token: "replace" (default) or "custom".
   */
  header_strategy?: string
}

/**
 * Type of registry (file, url, or default)
 */
export type V1RegistryType = 'file' | 'url' | 'api' | 'default'

/**
 * Request containing registry configuration updates
 */
export type V1UpdateRegistryRequest = {
  /**
   * Allow private IP addresses for registry URL or API URL
   */
  allow_private_ip?: boolean
  /**
   * MCP Registry API URL
   */
  api_url?: string
  /**
   * Local registry file path
   */
  local_path?: string
  /**
   * Registry URL (for remote registries)
   */
  url?: string
}

/**
 * Response containing update result
 */
export type V1UpdateRegistryResponse = {
  /**
   * Registry type after update
   */
  type?: string
}

/**
 * Request to build a skill from a local directory
 */
export type V1BuildSkillRequest = {
  /**
   * Path to the skill definition directory
   */
  path?: string
  /**
   * OCI tag for the built artifact
   */
  tag?: string
}

export type V1BulkClientRequest = {
  /**
   * Groups is the list of groups configured on the client.
   */
  groups?: Array<string>
  /**
   * Names is the list of client names to operate on.
   */
  names?: Array<ClientClientApp>
}

export type V1BulkOperationRequest = {
  /**
   * Group name to operate on (mutually exclusive with names)
   */
  group?: string
  /**
   * Names of the workloads to operate on
   */
  names?: Array<string>
}

export type V1ClientStatusResponse = {
  clients?: Array<ClientClientAppStatus>
}

export type V1CreateClientRequest = {
  /**
   * Groups is the list of groups configured on the client.
   */
  groups?: Array<string>
  name?: ClientClientApp
}

export type V1CreateClientResponse = {
  /**
   * Groups is the list of groups configured on the client.
   */
  groups?: Array<string>
  name?: ClientClientApp
}

export type V1CreateGroupRequest = {
  /**
   * Name of the group to create
   */
  name?: string
}

export type V1CreateGroupResponse = {
  /**
   * Name of the created group
   */
  name?: string
}

/**
 * Request to create a new workload
 */
export type V1CreateRequest = {
  /**
   * Authorization configuration
   */
  authz_config?: string
  /**
   * Command arguments to pass to the container
   */
  cmd_arguments?: Array<string>
  /**
   * Environment variables to set in the container
   */
  env_vars?: {
    [key: string]: string
  }
  /**
   * Group name this workload belongs to
   */
  group?: string
  header_forward?: V1HeaderForwardConfig
  headers?: Array<RegistryHeader>
  /**
   * Host to bind to
   */
  host?: string
  /**
   * Docker image to use
   */
  image?: string
  /**
   * Name of the workload
   */
  name?: string
  /**
   * Whether network isolation is turned on. This applies the rules in the permission profile.
   */
  network_isolation?: boolean
  oauth_config?: V1RemoteOAuthConfig
  oidc?: V1OidcOptions
  permission_profile?: PermissionsProfile
  /**
   * Proxy mode to use
   */
  proxy_mode?: string
  /**
   * Port for the HTTP proxy to listen on
   */
  proxy_port?: number
  /**
   * Secret parameters to inject
   */
  secrets?: Array<SecretsSecretParameter>
  /**
   * Port to expose from the container
   */
  target_port?: number
  /**
   * Tools filter
   */
  tools?: Array<string>
  /**
   * Tools override
   */
  tools_override?: {
    [key: string]: V1ToolOverride
  }
  /**
   * Transport configuration
   */
  transport?: string
  /**
   * Whether to trust X-Forwarded-* headers from reverse proxies
   */
  trust_proxy_headers?: boolean
  /**
   * Remote server specific fields
   */
  url?: string
  /**
   * Volume mounts
   */
  volumes?: Array<string>
}

/**
 * Request to create a new secret
 */
export type V1CreateSecretRequest = {
  /**
   * Secret key name
   */
  key?: string
  /**
   * Secret value
   */
  value?: string
}

/**
 * Response after creating a secret
 */
export type V1CreateSecretResponse = {
  /**
   * Secret key that was created
   */
  key?: string
  /**
   * Success message
   */
  message?: string
}

/**
 * Response after successfully creating a workload
 */
export type V1CreateWorkloadResponse = {
  /**
   * Name of the created workload
   */
  name?: string
  /**
   * Port the workload is listening on
   */
  port?: number
}

/**
 * Response containing registry details
 */
export type V1GetRegistryResponse = {
  /**
   * Last updated timestamp
   */
  last_updated?: string
  /**
   * Name of the registry
   */
  name?: string
  registry?: RegistryRegistry
  /**
   * Number of servers in the registry
   */
  server_count?: number
  /**
   * Source of the registry (URL, file path, or empty string for built-in)
   */
  source?: string
  type?: V1RegistryType
  /**
   * Version of the registry schema
   */
  version?: string
}

/**
 * Response containing secrets provider details
 */
export type V1GetSecretsProviderResponse = {
  capabilities?: V1ProviderCapabilitiesResponse
  /**
   * Name of the secrets provider
   */
  name?: string
  /**
   * Type of the secrets provider
   */
  provider_type?: string
}

/**
 * Response containing server details
 */
export type V1GetServerResponse = {
  /**
   * Indicates if this is a remote server
   */
  is_remote?: boolean
  remote_server?: RegistryRemoteServerMetadata
  server?: RegistryImageMetadata
}

export type V1GroupListResponse = {
  /**
   * List of groups
   */
  groups?: Array<GroupsGroup>
}

/**
 * HeaderForward configures headers to inject into requests to remote MCP servers.
 * Use this to add custom headers like X-Tenant-ID or correlation IDs.
 */
export type V1HeaderForwardConfig = {
  /**
   * AddHeadersFromSecret maps header names to secret names in ToolHive's secrets manager.
   * Key: HTTP header name, Value: secret name in the secrets manager
   */
  add_headers_from_secret?: {
    [key: string]: string
  }
  /**
   * AddPlaintextHeaders contains literal header values to inject.
   * WARNING: These values are stored and transmitted in plaintext.
   * Use AddHeadersFromSecret for sensitive data like API keys.
   */
  add_plaintext_headers?: {
    [key: string]: string
  }
}

/**
 * Request to install a skill
 */
export type V1InstallSkillRequest = {
  /**
   * Name or OCI reference of the skill to install
   */
  name?: string
  scope?: SkillsScope
  /**
   * Version to install (empty means latest)
   */
  version?: string
}

/**
 * Response after successfully installing a skill
 */
export type V1InstallSkillResponse = {
  skill?: SkillsInstalledSkill
}

/**
 * Response containing a list of secret keys
 */
export type V1ListSecretsResponse = {
  /**
   * List of secret keys
   */
  keys?: Array<V1SecretKeyResponse>
}

/**
 * Response containing a list of servers
 */
export type V1ListServersResponse = {
  /**
   * List of remote servers in the registry (if any)
   */
  remote_servers?: Array<RegistryRemoteServerMetadata>
  /**
   * List of container servers in the registry
   */
  servers?: Array<RegistryImageMetadata>
}

/**
 * OIDC configuration options
 */
export type V1OidcOptions = {
  /**
   * Expected audience
   */
  audience?: string
  /**
   * OAuth2 client ID
   */
  client_id?: string
  /**
   * OAuth2 client secret
   */
  client_secret?: string
  /**
   * Token introspection URL for OIDC
   */
  introspection_url?: string
  /**
   * OIDC issuer URL
   */
  issuer?: string
  /**
   * JWKS URL for key verification
   */
  jwks_url?: string
  /**
   * OAuth scopes to advertise in well-known endpoint (RFC 9728)
   */
  scopes?: Array<string>
}

/**
 * Capabilities of the secrets provider
 */
export type V1ProviderCapabilitiesResponse = {
  /**
   * Whether the provider can cleanup all secrets
   */
  can_cleanup?: boolean
  /**
   * Whether the provider can delete secrets
   */
  can_delete?: boolean
  /**
   * Whether the provider can list secrets
   */
  can_list?: boolean
  /**
   * Whether the provider can read secrets
   */
  can_read?: boolean
  /**
   * Whether the provider can write secrets
   */
  can_write?: boolean
}

/**
 * Request to push a built skill artifact
 */
export type V1PushSkillRequest = {
  /**
   * OCI reference to push
   */
  reference?: string
}

/**
 * Basic information about a registry
 */
export type V1RegistryInfo = {
  /**
   * Last updated timestamp
   */
  last_updated?: string
  /**
   * Name of the registry
   */
  name?: string
  /**
   * Number of servers in the registry
   */
  server_count?: number
  /**
   * Source of the registry (URL, file path, or empty string for built-in)
   */
  source?: string
  type?: V1RegistryType
  /**
   * Version of the registry schema
   */
  version?: string
}

/**
 * Response containing a list of registries
 */
export type V1RegistryListResponse = {
  /**
   * List of registries
   */
  registries?: Array<V1RegistryInfo>
}

/**
 * OAuth configuration for remote server authentication
 */
export type V1RemoteOAuthConfig = {
  /**
   * OAuth authorization endpoint URL (alternative to issuer for non-OIDC OAuth)
   */
  authorize_url?: string
  bearer_token?: SecretsSecretParameter
  /**
   * Specific port for OAuth callback server
   */
  callback_port?: number
  /**
   * OAuth client ID for authentication
   */
  client_id?: string
  client_secret?: SecretsSecretParameter
  /**
   * OAuth/OIDC issuer URL (e.g., https://accounts.google.com)
   */
  issuer?: string
  /**
   * Additional OAuth parameters for server-specific customization
   */
  oauth_params?: {
    [key: string]: string
  }
  /**
   * OAuth 2.0 resource indicator (RFC 8707)
   */
  resource?: string
  /**
   * OAuth scopes to request
   */
  scopes?: Array<string>
  /**
   * Whether to skip opening browser for OAuth flow (defaults to false)
   */
  skip_browser?: boolean
  /**
   * OAuth token endpoint URL (alternative to issuer for non-OIDC OAuth)
   */
  token_url?: string
  /**
   * Whether to use PKCE for the OAuth flow
   */
  use_pkce?: boolean
}

/**
 * Secret key information
 */
export type V1SecretKeyResponse = {
  /**
   * Optional description of the secret
   */
  description?: string
  /**
   * Secret key name
   */
  key?: string
}

/**
 * Request to setup a secrets provider
 */
export type V1SetupSecretsRequest = {
  /**
   * Password for encrypted provider (optional, can be set via environment variable)
   * TODO Review environment variable for this
   */
  password?: string
  /**
   * Type of the secrets provider (encrypted, 1password, environment)
   */
  provider_type?: string
}

/**
 * Response after initializing a secrets provider
 */
export type V1SetupSecretsResponse = {
  /**
   * Success message
   */
  message?: string
  /**
   * Type of the secrets provider that was setup
   */
  provider_type?: string
}

/**
 * Response containing a list of installed skills
 */
export type V1SkillListResponse = {
  /**
   * List of installed skills
   */
  skills?: Array<SkillsInstalledSkill>
}

/**
 * Tool override
 */
export type V1ToolOverride = {
  /**
   * Description of the tool
   */
  description?: string
  /**
   * Name of the tool
   */
  name?: string
}

/**
 * Request to update an existing workload (name cannot be changed)
 */
export type V1UpdateRequest = {
  /**
   * Authorization configuration
   */
  authz_config?: string
  /**
   * Command arguments to pass to the container
   */
  cmd_arguments?: Array<string>
  /**
   * Environment variables to set in the container
   */
  env_vars?: {
    [key: string]: string
  }
  /**
   * Group name this workload belongs to
   */
  group?: string
  header_forward?: V1HeaderForwardConfig
  headers?: Array<RegistryHeader>
  /**
   * Host to bind to
   */
  host?: string
  /**
   * Docker image to use
   */
  image?: string
  /**
   * Whether network isolation is turned on. This applies the rules in the permission profile.
   */
  network_isolation?: boolean
  oauth_config?: V1RemoteOAuthConfig
  oidc?: V1OidcOptions
  permission_profile?: PermissionsProfile
  /**
   * Proxy mode to use
   */
  proxy_mode?: string
  /**
   * Port for the HTTP proxy to listen on
   */
  proxy_port?: number
  /**
   * Secret parameters to inject
   */
  secrets?: Array<SecretsSecretParameter>
  /**
   * Port to expose from the container
   */
  target_port?: number
  /**
   * Tools filter
   */
  tools?: Array<string>
  /**
   * Tools override
   */
  tools_override?: {
    [key: string]: V1ToolOverride
  }
  /**
   * Transport configuration
   */
  transport?: string
  /**
   * Whether to trust X-Forwarded-* headers from reverse proxies
   */
  trust_proxy_headers?: boolean
  /**
   * Remote server specific fields
   */
  url?: string
  /**
   * Volume mounts
   */
  volumes?: Array<string>
}

/**
 * Request to update an existing secret
 */
export type V1UpdateSecretRequest = {
  /**
   * New secret value
   */
  value?: string
}

/**
 * Response after updating a secret
 */
export type V1UpdateSecretResponse = {
  /**
   * Secret key that was updated
   */
  key?: string
  /**
   * Success message
   */
  message?: string
}

/**
 * Request to validate a skill definition
 */
export type V1ValidateSkillRequest = {
  /**
   * Path to the skill definition directory
   */
  path?: string
}

export type V1VersionResponse = {
  version?: string
}

/**
 * Response containing a list of workloads
 */
export type V1WorkloadListResponse = {
  /**
   * List of container information for each workload
   */
  workloads?: Array<CoreWorkload>
}

/**
 * Response containing workload status information
 */
export type V1WorkloadStatusResponse = {
  status?: RuntimeWorkloadStatus
}

export type GetApiOpenapiJsonData = {
  body?: never
  path?: never
  query?: never
  url: '/api/openapi.json'
}

export type GetApiOpenapiJsonResponses = {
  /**
   * OpenAPI specification
   */
  200: {
    [key: string]: unknown
  }
}

export type GetApiOpenapiJsonResponse =
  GetApiOpenapiJsonResponses[keyof GetApiOpenapiJsonResponses]

export type GetApiV1BetaClientsData = {
  body?: never
  path?: never
  query?: never
  url: '/api/v1beta/clients'
}

export type GetApiV1BetaClientsResponses = {
  /**
   * OK
   */
  200: Array<ClientRegisteredClient>
}

export type GetApiV1BetaClientsResponse =
  GetApiV1BetaClientsResponses[keyof GetApiV1BetaClientsResponses]

export type PostApiV1BetaClientsData = {
  /**
   * Client to register
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1CreateClientRequest
  path?: never
  query?: never
  url: '/api/v1beta/clients'
}

export type PostApiV1BetaClientsErrors = {
  /**
   * Invalid request or unsupported client type
   */
  400: string
}

export type PostApiV1BetaClientsError =
  PostApiV1BetaClientsErrors[keyof PostApiV1BetaClientsErrors]

export type PostApiV1BetaClientsResponses = {
  /**
   * OK
   */
  200: V1CreateClientResponse
}

export type PostApiV1BetaClientsResponse =
  PostApiV1BetaClientsResponses[keyof PostApiV1BetaClientsResponses]

export type PostApiV1BetaClientsRegisterData = {
  /**
   * Clients to register
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1BulkClientRequest
  path?: never
  query?: never
  url: '/api/v1beta/clients/register'
}

export type PostApiV1BetaClientsRegisterErrors = {
  /**
   * Invalid request or unsupported client type
   */
  400: string
}

export type PostApiV1BetaClientsRegisterError =
  PostApiV1BetaClientsRegisterErrors[keyof PostApiV1BetaClientsRegisterErrors]

export type PostApiV1BetaClientsRegisterResponses = {
  /**
   * OK
   */
  200: Array<V1CreateClientResponse>
}

export type PostApiV1BetaClientsRegisterResponse =
  PostApiV1BetaClientsRegisterResponses[keyof PostApiV1BetaClientsRegisterResponses]

export type PostApiV1BetaClientsUnregisterData = {
  /**
   * Clients to unregister
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1BulkClientRequest
  path?: never
  query?: never
  url: '/api/v1beta/clients/unregister'
}

export type PostApiV1BetaClientsUnregisterErrors = {
  /**
   * Invalid request or unsupported client type
   */
  400: string
}

export type PostApiV1BetaClientsUnregisterError =
  PostApiV1BetaClientsUnregisterErrors[keyof PostApiV1BetaClientsUnregisterErrors]

export type PostApiV1BetaClientsUnregisterResponses = {
  /**
   * No Content
   */
  204: void
}

export type PostApiV1BetaClientsUnregisterResponse =
  PostApiV1BetaClientsUnregisterResponses[keyof PostApiV1BetaClientsUnregisterResponses]

export type DeleteApiV1BetaClientsByNameData = {
  body?: never
  path: {
    /**
     * Client name to unregister
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/clients/{name}'
}

export type DeleteApiV1BetaClientsByNameErrors = {
  /**
   * Invalid request or unsupported client type
   */
  400: string
}

export type DeleteApiV1BetaClientsByNameError =
  DeleteApiV1BetaClientsByNameErrors[keyof DeleteApiV1BetaClientsByNameErrors]

export type DeleteApiV1BetaClientsByNameResponses = {
  /**
   * No Content
   */
  204: void
}

export type DeleteApiV1BetaClientsByNameResponse =
  DeleteApiV1BetaClientsByNameResponses[keyof DeleteApiV1BetaClientsByNameResponses]

export type DeleteApiV1BetaClientsByNameGroupsByGroupData = {
  body?: never
  path: {
    /**
     * Client name to unregister
     */
    name: string
    /**
     * Group name to remove client from
     */
    group: string
  }
  query?: never
  url: '/api/v1beta/clients/{name}/groups/{group}'
}

export type DeleteApiV1BetaClientsByNameGroupsByGroupErrors = {
  /**
   * Invalid request or unsupported client type
   */
  400: string
  /**
   * Client or group not found
   */
  404: string
}

export type DeleteApiV1BetaClientsByNameGroupsByGroupError =
  DeleteApiV1BetaClientsByNameGroupsByGroupErrors[keyof DeleteApiV1BetaClientsByNameGroupsByGroupErrors]

export type DeleteApiV1BetaClientsByNameGroupsByGroupResponses = {
  /**
   * No Content
   */
  204: void
}

export type DeleteApiV1BetaClientsByNameGroupsByGroupResponse =
  DeleteApiV1BetaClientsByNameGroupsByGroupResponses[keyof DeleteApiV1BetaClientsByNameGroupsByGroupResponses]

export type GetApiV1BetaDiscoveryClientsData = {
  body?: never
  path?: never
  query?: never
  url: '/api/v1beta/discovery/clients'
}

export type GetApiV1BetaDiscoveryClientsResponses = {
  /**
   * OK
   */
  200: V1ClientStatusResponse
}

export type GetApiV1BetaDiscoveryClientsResponse =
  GetApiV1BetaDiscoveryClientsResponses[keyof GetApiV1BetaDiscoveryClientsResponses]

export type GetApiV1BetaGroupsData = {
  body?: never
  path?: never
  query?: never
  url: '/api/v1beta/groups'
}

export type GetApiV1BetaGroupsErrors = {
  /**
   * Internal Server Error
   */
  500: string
}

export type GetApiV1BetaGroupsError =
  GetApiV1BetaGroupsErrors[keyof GetApiV1BetaGroupsErrors]

export type GetApiV1BetaGroupsResponses = {
  /**
   * OK
   */
  200: V1GroupListResponse
}

export type GetApiV1BetaGroupsResponse =
  GetApiV1BetaGroupsResponses[keyof GetApiV1BetaGroupsResponses]

export type PostApiV1BetaGroupsData = {
  /**
   * Group creation request
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1CreateGroupRequest
  path?: never
  query?: never
  url: '/api/v1beta/groups'
}

export type PostApiV1BetaGroupsErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Conflict
   */
  409: string
  /**
   * Internal Server Error
   */
  500: string
}

export type PostApiV1BetaGroupsError =
  PostApiV1BetaGroupsErrors[keyof PostApiV1BetaGroupsErrors]

export type PostApiV1BetaGroupsResponses = {
  /**
   * Created
   */
  201: V1CreateGroupResponse
}

export type PostApiV1BetaGroupsResponse =
  PostApiV1BetaGroupsResponses[keyof PostApiV1BetaGroupsResponses]

export type DeleteApiV1BetaGroupsByNameData = {
  body?: never
  path: {
    /**
     * Group name
     */
    name: string
  }
  query?: {
    /**
     * Delete all workloads in the group (default: false, moves workloads to default group)
     */
    'with-workloads'?: boolean
  }
  url: '/api/v1beta/groups/{name}'
}

export type DeleteApiV1BetaGroupsByNameErrors = {
  /**
   * Not Found
   */
  404: string
  /**
   * Internal Server Error
   */
  500: string
}

export type DeleteApiV1BetaGroupsByNameError =
  DeleteApiV1BetaGroupsByNameErrors[keyof DeleteApiV1BetaGroupsByNameErrors]

export type DeleteApiV1BetaGroupsByNameResponses = {
  /**
   * No Content
   */
  204: string
}

export type DeleteApiV1BetaGroupsByNameResponse =
  DeleteApiV1BetaGroupsByNameResponses[keyof DeleteApiV1BetaGroupsByNameResponses]

export type GetApiV1BetaGroupsByNameData = {
  body?: never
  path: {
    /**
     * Group name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/groups/{name}'
}

export type GetApiV1BetaGroupsByNameErrors = {
  /**
   * Not Found
   */
  404: string
  /**
   * Internal Server Error
   */
  500: string
}

export type GetApiV1BetaGroupsByNameError =
  GetApiV1BetaGroupsByNameErrors[keyof GetApiV1BetaGroupsByNameErrors]

export type GetApiV1BetaGroupsByNameResponses = {
  /**
   * OK
   */
  200: GroupsGroup
}

export type GetApiV1BetaGroupsByNameResponse =
  GetApiV1BetaGroupsByNameResponses[keyof GetApiV1BetaGroupsByNameResponses]

export type GetApiV1BetaRegistryData = {
  body?: never
  path?: never
  query?: never
  url: '/api/v1beta/registry'
}

export type GetApiV1BetaRegistryResponses = {
  /**
   * OK
   */
  200: V1RegistryListResponse
}

export type GetApiV1BetaRegistryResponse =
  GetApiV1BetaRegistryResponses[keyof GetApiV1BetaRegistryResponses]

export type PostApiV1BetaRegistryData = {
  body?: {
    [key: string]: unknown
  }
  path?: never
  query?: never
  url: '/api/v1beta/registry'
}

export type PostApiV1BetaRegistryErrors = {
  /**
   * Not Implemented
   */
  501: string
}

export type PostApiV1BetaRegistryError =
  PostApiV1BetaRegistryErrors[keyof PostApiV1BetaRegistryErrors]

export type DeleteApiV1BetaRegistryByNameData = {
  body?: never
  path: {
    /**
     * Registry name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/registry/{name}'
}

export type DeleteApiV1BetaRegistryByNameErrors = {
  /**
   * Not Found
   */
  404: string
}

export type DeleteApiV1BetaRegistryByNameError =
  DeleteApiV1BetaRegistryByNameErrors[keyof DeleteApiV1BetaRegistryByNameErrors]

export type DeleteApiV1BetaRegistryByNameResponses = {
  /**
   * No Content
   */
  204: string
}

export type DeleteApiV1BetaRegistryByNameResponse =
  DeleteApiV1BetaRegistryByNameResponses[keyof DeleteApiV1BetaRegistryByNameResponses]

export type GetApiV1BetaRegistryByNameData = {
  body?: never
  path: {
    /**
     * Registry name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/registry/{name}'
}

export type GetApiV1BetaRegistryByNameErrors = {
  /**
   * Not Found
   */
  404: string
}

export type GetApiV1BetaRegistryByNameError =
  GetApiV1BetaRegistryByNameErrors[keyof GetApiV1BetaRegistryByNameErrors]

export type GetApiV1BetaRegistryByNameResponses = {
  /**
   * OK
   */
  200: V1GetRegistryResponse
}

export type GetApiV1BetaRegistryByNameResponse =
  GetApiV1BetaRegistryByNameResponses[keyof GetApiV1BetaRegistryByNameResponses]

export type PutApiV1BetaRegistryByNameData = {
  /**
   * Registry configuration
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1UpdateRegistryRequest
  path: {
    /**
     * Registry name (must be 'default')
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/registry/{name}'
}

export type PutApiV1BetaRegistryByNameErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found
   */
  404: string
  /**
   * Bad Gateway - Registry validation failed
   */
  502: string
  /**
   * Gateway Timeout - Registry unreachable
   */
  504: string
}

export type PutApiV1BetaRegistryByNameError =
  PutApiV1BetaRegistryByNameErrors[keyof PutApiV1BetaRegistryByNameErrors]

export type PutApiV1BetaRegistryByNameResponses = {
  /**
   * OK
   */
  200: V1UpdateRegistryResponse
}

export type PutApiV1BetaRegistryByNameResponse =
  PutApiV1BetaRegistryByNameResponses[keyof PutApiV1BetaRegistryByNameResponses]

export type GetApiV1BetaRegistryByNameServersData = {
  body?: never
  path: {
    /**
     * Registry name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/registry/{name}/servers'
}

export type GetApiV1BetaRegistryByNameServersErrors = {
  /**
   * Not Found
   */
  404: string
}

export type GetApiV1BetaRegistryByNameServersError =
  GetApiV1BetaRegistryByNameServersErrors[keyof GetApiV1BetaRegistryByNameServersErrors]

export type GetApiV1BetaRegistryByNameServersResponses = {
  /**
   * OK
   */
  200: V1ListServersResponse
}

export type GetApiV1BetaRegistryByNameServersResponse =
  GetApiV1BetaRegistryByNameServersResponses[keyof GetApiV1BetaRegistryByNameServersResponses]

export type GetApiV1BetaRegistryByNameServersByServerNameData = {
  body?: never
  path: {
    /**
     * Registry name
     */
    name: string
    /**
     * ImageMetadata name
     */
    serverName: string
  }
  query?: never
  url: '/api/v1beta/registry/{name}/servers/{serverName}'
}

export type GetApiV1BetaRegistryByNameServersByServerNameErrors = {
  /**
   * Not Found
   */
  404: string
}

export type GetApiV1BetaRegistryByNameServersByServerNameError =
  GetApiV1BetaRegistryByNameServersByServerNameErrors[keyof GetApiV1BetaRegistryByNameServersByServerNameErrors]

export type GetApiV1BetaRegistryByNameServersByServerNameResponses = {
  /**
   * OK
   */
  200: V1GetServerResponse
}

export type GetApiV1BetaRegistryByNameServersByServerNameResponse =
  GetApiV1BetaRegistryByNameServersByServerNameResponses[keyof GetApiV1BetaRegistryByNameServersByServerNameResponses]

export type PostApiV1BetaSecretsData = {
  /**
   * Setup secrets provider request
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1SetupSecretsRequest
  path?: never
  query?: never
  url: '/api/v1beta/secrets'
}

export type PostApiV1BetaSecretsErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Internal Server Error
   */
  500: string
}

export type PostApiV1BetaSecretsError =
  PostApiV1BetaSecretsErrors[keyof PostApiV1BetaSecretsErrors]

export type PostApiV1BetaSecretsResponses = {
  /**
   * Created
   */
  201: V1SetupSecretsResponse
}

export type PostApiV1BetaSecretsResponse =
  PostApiV1BetaSecretsResponses[keyof PostApiV1BetaSecretsResponses]

export type GetApiV1BetaSecretsDefaultData = {
  body?: never
  path?: never
  query?: never
  url: '/api/v1beta/secrets/default'
}

export type GetApiV1BetaSecretsDefaultErrors = {
  /**
   * Not Found - Provider not setup
   */
  404: string
  /**
   * Internal Server Error
   */
  500: string
}

export type GetApiV1BetaSecretsDefaultError =
  GetApiV1BetaSecretsDefaultErrors[keyof GetApiV1BetaSecretsDefaultErrors]

export type GetApiV1BetaSecretsDefaultResponses = {
  /**
   * OK
   */
  200: V1GetSecretsProviderResponse
}

export type GetApiV1BetaSecretsDefaultResponse =
  GetApiV1BetaSecretsDefaultResponses[keyof GetApiV1BetaSecretsDefaultResponses]

export type GetApiV1BetaSecretsDefaultKeysData = {
  body?: never
  path?: never
  query?: never
  url: '/api/v1beta/secrets/default/keys'
}

export type GetApiV1BetaSecretsDefaultKeysErrors = {
  /**
   * Not Found - Provider not setup
   */
  404: string
  /**
   * Method Not Allowed - Provider doesn't support listing
   */
  405: string
  /**
   * Internal Server Error
   */
  500: string
}

export type GetApiV1BetaSecretsDefaultKeysError =
  GetApiV1BetaSecretsDefaultKeysErrors[keyof GetApiV1BetaSecretsDefaultKeysErrors]

export type GetApiV1BetaSecretsDefaultKeysResponses = {
  /**
   * OK
   */
  200: V1ListSecretsResponse
}

export type GetApiV1BetaSecretsDefaultKeysResponse =
  GetApiV1BetaSecretsDefaultKeysResponses[keyof GetApiV1BetaSecretsDefaultKeysResponses]

export type PostApiV1BetaSecretsDefaultKeysData = {
  /**
   * Create secret request
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1CreateSecretRequest
  path?: never
  query?: never
  url: '/api/v1beta/secrets/default/keys'
}

export type PostApiV1BetaSecretsDefaultKeysErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found - Provider not setup
   */
  404: string
  /**
   * Method Not Allowed - Provider doesn't support writing
   */
  405: string
  /**
   * Conflict - Secret already exists
   */
  409: string
  /**
   * Internal Server Error
   */
  500: string
}

export type PostApiV1BetaSecretsDefaultKeysError =
  PostApiV1BetaSecretsDefaultKeysErrors[keyof PostApiV1BetaSecretsDefaultKeysErrors]

export type PostApiV1BetaSecretsDefaultKeysResponses = {
  /**
   * Created
   */
  201: V1CreateSecretResponse
}

export type PostApiV1BetaSecretsDefaultKeysResponse =
  PostApiV1BetaSecretsDefaultKeysResponses[keyof PostApiV1BetaSecretsDefaultKeysResponses]

export type DeleteApiV1BetaSecretsDefaultKeysByKeyData = {
  body?: never
  path: {
    /**
     * Secret key
     */
    key: string
  }
  query?: never
  url: '/api/v1beta/secrets/default/keys/{key}'
}

export type DeleteApiV1BetaSecretsDefaultKeysByKeyErrors = {
  /**
   * Not Found - Provider not setup or secret not found
   */
  404: string
  /**
   * Method Not Allowed - Provider doesn't support deletion
   */
  405: string
  /**
   * Internal Server Error
   */
  500: string
}

export type DeleteApiV1BetaSecretsDefaultKeysByKeyError =
  DeleteApiV1BetaSecretsDefaultKeysByKeyErrors[keyof DeleteApiV1BetaSecretsDefaultKeysByKeyErrors]

export type DeleteApiV1BetaSecretsDefaultKeysByKeyResponses = {
  /**
   * No Content
   */
  204: string
}

export type DeleteApiV1BetaSecretsDefaultKeysByKeyResponse =
  DeleteApiV1BetaSecretsDefaultKeysByKeyResponses[keyof DeleteApiV1BetaSecretsDefaultKeysByKeyResponses]

export type PutApiV1BetaSecretsDefaultKeysByKeyData = {
  /**
   * Update secret request
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1UpdateSecretRequest
  path: {
    /**
     * Secret key
     */
    key: string
  }
  query?: never
  url: '/api/v1beta/secrets/default/keys/{key}'
}

export type PutApiV1BetaSecretsDefaultKeysByKeyErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found - Provider not setup or secret not found
   */
  404: string
  /**
   * Method Not Allowed - Provider doesn't support writing
   */
  405: string
  /**
   * Internal Server Error
   */
  500: string
}

export type PutApiV1BetaSecretsDefaultKeysByKeyError =
  PutApiV1BetaSecretsDefaultKeysByKeyErrors[keyof PutApiV1BetaSecretsDefaultKeysByKeyErrors]

export type PutApiV1BetaSecretsDefaultKeysByKeyResponses = {
  /**
   * OK
   */
  200: V1UpdateSecretResponse
}

export type PutApiV1BetaSecretsDefaultKeysByKeyResponse =
  PutApiV1BetaSecretsDefaultKeysByKeyResponses[keyof PutApiV1BetaSecretsDefaultKeysByKeyResponses]

export type GetApiV1BetaSkillsData = {
  body?: never
  path?: never
  query?: {
    /**
     * Filter by scope (user or project)
     */
    scope?: 'user' | 'project'
  }
  url: '/api/v1beta/skills'
}

export type GetApiV1BetaSkillsErrors = {
  /**
   * Internal Server Error
   */
  500: string
}

export type GetApiV1BetaSkillsError =
  GetApiV1BetaSkillsErrors[keyof GetApiV1BetaSkillsErrors]

export type GetApiV1BetaSkillsResponses = {
  /**
   * OK
   */
  200: V1SkillListResponse
}

export type GetApiV1BetaSkillsResponse =
  GetApiV1BetaSkillsResponses[keyof GetApiV1BetaSkillsResponses]

export type PostApiV1BetaSkillsData = {
  /**
   * Install request
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1InstallSkillRequest
  path?: never
  query?: never
  url: '/api/v1beta/skills'
}

export type PostApiV1BetaSkillsErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Conflict
   */
  409: string
  /**
   * Internal Server Error
   */
  500: string
}

export type PostApiV1BetaSkillsError =
  PostApiV1BetaSkillsErrors[keyof PostApiV1BetaSkillsErrors]

export type PostApiV1BetaSkillsResponses = {
  /**
   * Created
   */
  201: V1InstallSkillResponse
}

export type PostApiV1BetaSkillsResponse =
  PostApiV1BetaSkillsResponses[keyof PostApiV1BetaSkillsResponses]

export type PostApiV1BetaSkillsBuildData = {
  /**
   * Build request
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1BuildSkillRequest
  path?: never
  query?: never
  url: '/api/v1beta/skills/build'
}

export type PostApiV1BetaSkillsBuildErrors = {
  /**
   * Not Implemented
   */
  501: string
}

export type PostApiV1BetaSkillsBuildError =
  PostApiV1BetaSkillsBuildErrors[keyof PostApiV1BetaSkillsBuildErrors]

export type PostApiV1BetaSkillsBuildResponses = {
  /**
   * OK
   */
  200: SkillsBuildResult
}

export type PostApiV1BetaSkillsBuildResponse =
  PostApiV1BetaSkillsBuildResponses[keyof PostApiV1BetaSkillsBuildResponses]

export type PostApiV1BetaSkillsPushData = {
  /**
   * Push request
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1PushSkillRequest
  path?: never
  query?: never
  url: '/api/v1beta/skills/push'
}

export type PostApiV1BetaSkillsPushErrors = {
  /**
   * Not Implemented
   */
  501: string
}

export type PostApiV1BetaSkillsPushError =
  PostApiV1BetaSkillsPushErrors[keyof PostApiV1BetaSkillsPushErrors]

export type PostApiV1BetaSkillsPushResponses = {
  /**
   * No Content
   */
  204: string
}

export type PostApiV1BetaSkillsPushResponse =
  PostApiV1BetaSkillsPushResponses[keyof PostApiV1BetaSkillsPushResponses]

export type PostApiV1BetaSkillsValidateData = {
  /**
   * Validate request
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1ValidateSkillRequest
  path?: never
  query?: never
  url: '/api/v1beta/skills/validate'
}

export type PostApiV1BetaSkillsValidateErrors = {
  /**
   * Not Implemented
   */
  501: string
}

export type PostApiV1BetaSkillsValidateError =
  PostApiV1BetaSkillsValidateErrors[keyof PostApiV1BetaSkillsValidateErrors]

export type PostApiV1BetaSkillsValidateResponses = {
  /**
   * OK
   */
  200: SkillsValidationResult
}

export type PostApiV1BetaSkillsValidateResponse =
  PostApiV1BetaSkillsValidateResponses[keyof PostApiV1BetaSkillsValidateResponses]

export type DeleteApiV1BetaSkillsByNameData = {
  body?: never
  path: {
    /**
     * Skill name
     */
    name: string
  }
  query?: {
    /**
     * Scope to uninstall from (user or project)
     */
    scope?: 'user' | 'project'
  }
  url: '/api/v1beta/skills/{name}'
}

export type DeleteApiV1BetaSkillsByNameErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found
   */
  404: string
  /**
   * Internal Server Error
   */
  500: string
}

export type DeleteApiV1BetaSkillsByNameError =
  DeleteApiV1BetaSkillsByNameErrors[keyof DeleteApiV1BetaSkillsByNameErrors]

export type DeleteApiV1BetaSkillsByNameResponses = {
  /**
   * No Content
   */
  204: string
}

export type DeleteApiV1BetaSkillsByNameResponse =
  DeleteApiV1BetaSkillsByNameResponses[keyof DeleteApiV1BetaSkillsByNameResponses]

export type GetApiV1BetaSkillsByNameData = {
  body?: never
  path: {
    /**
     * Skill name
     */
    name: string
  }
  query?: {
    /**
     * Filter by scope (user or project)
     */
    scope?: 'user' | 'project'
  }
  url: '/api/v1beta/skills/{name}'
}

export type GetApiV1BetaSkillsByNameErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found
   */
  404: string
  /**
   * Internal Server Error
   */
  500: string
}

export type GetApiV1BetaSkillsByNameError =
  GetApiV1BetaSkillsByNameErrors[keyof GetApiV1BetaSkillsByNameErrors]

export type GetApiV1BetaSkillsByNameResponses = {
  /**
   * OK
   */
  200: SkillsSkillInfo
}

export type GetApiV1BetaSkillsByNameResponse =
  GetApiV1BetaSkillsByNameResponses[keyof GetApiV1BetaSkillsByNameResponses]

export type GetApiV1BetaVersionData = {
  body?: never
  path?: never
  query?: never
  url: '/api/v1beta/version'
}

export type GetApiV1BetaVersionResponses = {
  /**
   * OK
   */
  200: V1VersionResponse
}

export type GetApiV1BetaVersionResponse =
  GetApiV1BetaVersionResponses[keyof GetApiV1BetaVersionResponses]

export type GetApiV1BetaWorkloadsData = {
  body?: never
  path?: never
  query?: {
    /**
     * List all workloads, including stopped ones
     */
    all?: boolean
    /**
     * Filter workloads by group name
     */
    group?: string
  }
  url: '/api/v1beta/workloads'
}

export type GetApiV1BetaWorkloadsErrors = {
  /**
   * Group not found
   */
  404: string
}

export type GetApiV1BetaWorkloadsError =
  GetApiV1BetaWorkloadsErrors[keyof GetApiV1BetaWorkloadsErrors]

export type GetApiV1BetaWorkloadsResponses = {
  /**
   * OK
   */
  200: V1WorkloadListResponse
}

export type GetApiV1BetaWorkloadsResponse =
  GetApiV1BetaWorkloadsResponses[keyof GetApiV1BetaWorkloadsResponses]

export type PostApiV1BetaWorkloadsData = {
  /**
   * Create workload request
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1CreateRequest
  path?: never
  query?: never
  url: '/api/v1beta/workloads'
}

export type PostApiV1BetaWorkloadsErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Conflict
   */
  409: string
}

export type PostApiV1BetaWorkloadsError =
  PostApiV1BetaWorkloadsErrors[keyof PostApiV1BetaWorkloadsErrors]

export type PostApiV1BetaWorkloadsResponses = {
  /**
   * Created
   */
  201: V1CreateWorkloadResponse
}

export type PostApiV1BetaWorkloadsResponse =
  PostApiV1BetaWorkloadsResponses[keyof PostApiV1BetaWorkloadsResponses]

export type PostApiV1BetaWorkloadsDeleteData = {
  /**
   * Bulk delete request (names or group)
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1BulkOperationRequest
  path?: never
  query?: never
  url: '/api/v1beta/workloads/delete'
}

export type PostApiV1BetaWorkloadsDeleteErrors = {
  /**
   * Bad Request
   */
  400: string
}

export type PostApiV1BetaWorkloadsDeleteError =
  PostApiV1BetaWorkloadsDeleteErrors[keyof PostApiV1BetaWorkloadsDeleteErrors]

export type PostApiV1BetaWorkloadsDeleteResponses = {
  /**
   * Accepted - deletion started
   */
  202: string
}

export type PostApiV1BetaWorkloadsDeleteResponse =
  PostApiV1BetaWorkloadsDeleteResponses[keyof PostApiV1BetaWorkloadsDeleteResponses]

export type PostApiV1BetaWorkloadsRestartData = {
  /**
   * Bulk restart request (names or group)
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1BulkOperationRequest
  path?: never
  query?: never
  url: '/api/v1beta/workloads/restart'
}

export type PostApiV1BetaWorkloadsRestartErrors = {
  /**
   * Bad Request
   */
  400: string
}

export type PostApiV1BetaWorkloadsRestartError =
  PostApiV1BetaWorkloadsRestartErrors[keyof PostApiV1BetaWorkloadsRestartErrors]

export type PostApiV1BetaWorkloadsRestartResponses = {
  /**
   * Accepted
   */
  202: string
}

export type PostApiV1BetaWorkloadsRestartResponse =
  PostApiV1BetaWorkloadsRestartResponses[keyof PostApiV1BetaWorkloadsRestartResponses]

export type PostApiV1BetaWorkloadsStopData = {
  /**
   * Bulk stop request (names or group)
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1BulkOperationRequest
  path?: never
  query?: never
  url: '/api/v1beta/workloads/stop'
}

export type PostApiV1BetaWorkloadsStopErrors = {
  /**
   * Bad Request
   */
  400: string
}

export type PostApiV1BetaWorkloadsStopError =
  PostApiV1BetaWorkloadsStopErrors[keyof PostApiV1BetaWorkloadsStopErrors]

export type PostApiV1BetaWorkloadsStopResponses = {
  /**
   * Accepted
   */
  202: string
}

export type PostApiV1BetaWorkloadsStopResponse =
  PostApiV1BetaWorkloadsStopResponses[keyof PostApiV1BetaWorkloadsStopResponses]

export type DeleteApiV1BetaWorkloadsByNameData = {
  body?: never
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}'
}

export type DeleteApiV1BetaWorkloadsByNameErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found
   */
  404: string
}

export type DeleteApiV1BetaWorkloadsByNameError =
  DeleteApiV1BetaWorkloadsByNameErrors[keyof DeleteApiV1BetaWorkloadsByNameErrors]

export type DeleteApiV1BetaWorkloadsByNameResponses = {
  /**
   * Accepted - deletion started
   */
  202: string
}

export type DeleteApiV1BetaWorkloadsByNameResponse =
  DeleteApiV1BetaWorkloadsByNameResponses[keyof DeleteApiV1BetaWorkloadsByNameResponses]

export type GetApiV1BetaWorkloadsByNameData = {
  body?: never
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}'
}

export type GetApiV1BetaWorkloadsByNameErrors = {
  /**
   * Not Found
   */
  404: string
}

export type GetApiV1BetaWorkloadsByNameError =
  GetApiV1BetaWorkloadsByNameErrors[keyof GetApiV1BetaWorkloadsByNameErrors]

export type GetApiV1BetaWorkloadsByNameResponses = {
  /**
   * OK
   */
  200: V1CreateRequest
}

export type GetApiV1BetaWorkloadsByNameResponse =
  GetApiV1BetaWorkloadsByNameResponses[keyof GetApiV1BetaWorkloadsByNameResponses]

export type PostApiV1BetaWorkloadsByNameEditData = {
  /**
   * Update workload request
   */
  body:
    | {
        [key: string]: unknown
      }
    | V1UpdateRequest
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}/edit'
}

export type PostApiV1BetaWorkloadsByNameEditErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found
   */
  404: string
}

export type PostApiV1BetaWorkloadsByNameEditError =
  PostApiV1BetaWorkloadsByNameEditErrors[keyof PostApiV1BetaWorkloadsByNameEditErrors]

export type PostApiV1BetaWorkloadsByNameEditResponses = {
  /**
   * OK
   */
  200: V1CreateWorkloadResponse
}

export type PostApiV1BetaWorkloadsByNameEditResponse =
  PostApiV1BetaWorkloadsByNameEditResponses[keyof PostApiV1BetaWorkloadsByNameEditResponses]

export type GetApiV1BetaWorkloadsByNameExportData = {
  body?: never
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}/export'
}

export type GetApiV1BetaWorkloadsByNameExportErrors = {
  /**
   * Not Found
   */
  404: string
}

export type GetApiV1BetaWorkloadsByNameExportError =
  GetApiV1BetaWorkloadsByNameExportErrors[keyof GetApiV1BetaWorkloadsByNameExportErrors]

export type GetApiV1BetaWorkloadsByNameExportResponses = {
  /**
   * OK
   */
  200: RunnerRunConfig
}

export type GetApiV1BetaWorkloadsByNameExportResponse =
  GetApiV1BetaWorkloadsByNameExportResponses[keyof GetApiV1BetaWorkloadsByNameExportResponses]

export type GetApiV1BetaWorkloadsByNameLogsData = {
  body?: never
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}/logs'
}

export type GetApiV1BetaWorkloadsByNameLogsErrors = {
  /**
   * Invalid workload name
   */
  400: string
  /**
   * Not Found
   */
  404: string
}

export type GetApiV1BetaWorkloadsByNameLogsError =
  GetApiV1BetaWorkloadsByNameLogsErrors[keyof GetApiV1BetaWorkloadsByNameLogsErrors]

export type GetApiV1BetaWorkloadsByNameLogsResponses = {
  /**
   * Logs for the specified workload
   */
  200: string
}

export type GetApiV1BetaWorkloadsByNameLogsResponse =
  GetApiV1BetaWorkloadsByNameLogsResponses[keyof GetApiV1BetaWorkloadsByNameLogsResponses]

export type GetApiV1BetaWorkloadsByNameProxyLogsData = {
  body?: never
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}/proxy-logs'
}

export type GetApiV1BetaWorkloadsByNameProxyLogsErrors = {
  /**
   * Invalid workload name
   */
  400: string
  /**
   * Proxy logs not found for workload
   */
  404: string
}

export type GetApiV1BetaWorkloadsByNameProxyLogsError =
  GetApiV1BetaWorkloadsByNameProxyLogsErrors[keyof GetApiV1BetaWorkloadsByNameProxyLogsErrors]

export type GetApiV1BetaWorkloadsByNameProxyLogsResponses = {
  /**
   * Proxy logs for the specified workload
   */
  200: string
}

export type GetApiV1BetaWorkloadsByNameProxyLogsResponse =
  GetApiV1BetaWorkloadsByNameProxyLogsResponses[keyof GetApiV1BetaWorkloadsByNameProxyLogsResponses]

export type PostApiV1BetaWorkloadsByNameRestartData = {
  body?: never
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}/restart'
}

export type PostApiV1BetaWorkloadsByNameRestartErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found
   */
  404: string
}

export type PostApiV1BetaWorkloadsByNameRestartError =
  PostApiV1BetaWorkloadsByNameRestartErrors[keyof PostApiV1BetaWorkloadsByNameRestartErrors]

export type PostApiV1BetaWorkloadsByNameRestartResponses = {
  /**
   * Accepted
   */
  202: string
}

export type PostApiV1BetaWorkloadsByNameRestartResponse =
  PostApiV1BetaWorkloadsByNameRestartResponses[keyof PostApiV1BetaWorkloadsByNameRestartResponses]

export type GetApiV1BetaWorkloadsByNameStatusData = {
  body?: never
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}/status'
}

export type GetApiV1BetaWorkloadsByNameStatusErrors = {
  /**
   * Not Found
   */
  404: string
}

export type GetApiV1BetaWorkloadsByNameStatusError =
  GetApiV1BetaWorkloadsByNameStatusErrors[keyof GetApiV1BetaWorkloadsByNameStatusErrors]

export type GetApiV1BetaWorkloadsByNameStatusResponses = {
  /**
   * OK
   */
  200: V1WorkloadStatusResponse
}

export type GetApiV1BetaWorkloadsByNameStatusResponse =
  GetApiV1BetaWorkloadsByNameStatusResponses[keyof GetApiV1BetaWorkloadsByNameStatusResponses]

export type PostApiV1BetaWorkloadsByNameStopData = {
  body?: never
  path: {
    /**
     * Workload name
     */
    name: string
  }
  query?: never
  url: '/api/v1beta/workloads/{name}/stop'
}

export type PostApiV1BetaWorkloadsByNameStopErrors = {
  /**
   * Bad Request
   */
  400: string
  /**
   * Not Found
   */
  404: string
}

export type PostApiV1BetaWorkloadsByNameStopError =
  PostApiV1BetaWorkloadsByNameStopErrors[keyof PostApiV1BetaWorkloadsByNameStopErrors]

export type PostApiV1BetaWorkloadsByNameStopResponses = {
  /**
   * Accepted
   */
  202: string
}

export type PostApiV1BetaWorkloadsByNameStopResponse =
  PostApiV1BetaWorkloadsByNameStopResponses[keyof PostApiV1BetaWorkloadsByNameStopResponses]

export type GetHealthData = {
  body?: never
  path?: never
  query?: never
  url: '/health'
}

export type GetHealthResponses = {
  /**
   * No Content
   */
  204: string
}

export type GetHealthResponse = GetHealthResponses[keyof GetHealthResponses]
